#!/usr/bin/perl -w
######################################################################################################
# /usr/sbin/fc-node-configuration
######################################################################################################
#
# Copyright (C) 2013 FOSS-Group
#                    Germany
#                    http://www.foss-group.de
#                    support@foss-group.de
#
# Authors:
#   Pat Kläy  <pat.klaey@stepping-stone.ch>
#   Michael Eichenberger <michael.eichenberger@stepping-stone.ch>
#   Beat Stebler <beat.stebler@foss-group.ch>
#
# Licensed under the EUPL, Version 1.1 or – as soon they
# will be approved by the European Commission - subsequent
# versions of the EUPL (the "Licence");
# You may not use this work except in compliance with the
# Licence.
# You may obtain a copy of the Licence at:
#
# https://joinup.ec.europa.eu/software/page/eupl
#
# Unless required by applicable law or agreed to in
# writing, software distributed under the Licence is
# distributed on an "AS IS" basis,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied.
# See the Licence for the specific language governing
# permissions and limitations under the Licence.
#
# 
#
######################################################################################################

######################################################################################################
# Incorporate code with use (evaluates the included file at compile time).
######################################################################################################
use warnings;
use strict;

use Getopt::Long;
Getopt::Long::Configure("no_auto_abbrev");
use Term::ReadKey;
use Sys::Syslog;
use JSON::XS;
use File::Path;
use Net::OpenSSH;
use NetAddr::IP;
use Cwd "abs_path";
use File::Basename;
use Config::IniFiles;
use Net::LDAP;
use Net::LDAP::Constant qw(
  LDAP_SUCCESS
);
use Crypt::GeneratePassword qw(chars);
use POSIX;
use File::Copy;


$| = 1;                        # Turn buffering off, so that the output is flushed immediately

######################################################################################################
# Start the POD documentation information
######################################################################################################
=pod
 
=head1 NAME
 
fc-node-configuration
 
=head1 DESCRIPTION
 
This script gets the arguments from  ...
  
The script uses syslog for logging purposes.

Command Line Interface (CLI) parameters:
 
=over
 
=item -h|--help

Displays the help text

=item -n|--node-type TYPE

TYPE is either "primary-storage-node", "secondary-storage-node", "primary-master-node", "secondary-master-node" or "vm-node".

=item --dry-run

Runs script in dry-run, what means that no changes are done, only the output
is generated and displayed.

=item -d debug

Shows debug information.

=back

=head1 USAGE

./fc-node-configuration --node-type primary-master-node

./fc-node-configuration --node-type secondary-master-node

./fc-node-configuration --node-type primary-storage-node 

./fc-node-configuration --node-type secondary-storage-node

./fc-node-configuration --node-type vm-node

./fc-node-configuration --node-type demo-system

=head1 TESTING

To check the exit code manually:

=over

echo $?

=back

Note, that the exit code 0 means success. 1 or larger means failure. 

=head1 CREATED
 
2011-11-30 pat.klaey@stepping-stone.ch created
 
=head1 VERSION
 
=over
 
=item 2011-11-30 pat.klaey@stepping-stone.ch created

=item 2011-12-04 michael.eichenberger@stepping-stone.ch updated
 
=item 2014-12-07 08 beat.stebler@foss-group update create gluster volume

=back
 
=head1 INCORPORATED CODE
 
Incorporated code with use:
 
=over
 
=over
 
=item warnings;
 
=item strict;
 
=item Getopt::Long;

=item Term::ReadKey;
 
=item Sys::Syslog;

=item JSON::XS;

=item Net::OpenSSH;

=back
 
=back
 
=cut
######################################################################################################
# End the POD documentation information
######################################################################################################

######################################################################################################
# Read the configuration file
######################################################################################################
my $location=dirname(abs_path($0));

my $config_file_path = "/etc/foss-cloud";

my $cfg = Config::IniFiles->new( -file => "$config_file_path/node-configuration.conf" , -nomultiline => 1 );

######################################################################################################
# Process the single character or long command line arguments.
######################################################################################################
my %opts;
GetOptions (
  \%opts,
  "dry-run",        # If passed to the script via CLI, then true.
  "d",              # Shows debugging information.
  "help|h",         # This option will display a short help message.
  "node-type|n:s",  # The type name, is mandatory.
  "password|p:s",   # Password for phpldapadmin
); 

######################################################################################################
# Variable definitions
######################################################################################################
my $debug = 0;      # Debug modus: 0: off, 1: on
my $dryrun = 0;     # Dry-Run modus: 0: off, 1: on

my $password = "";
my $prov_backup_kvm_password = "";
my $prov_backup_kvm_unencrypted_password = "";
my $fc_brokerd_unencrypted_password = "";
my $dhcp_password = "";
my $dhcp_unencrypted_password = "";
my $modus = "";

# For secondary master node
my $primary_master_host = "";
my $primary_master_user = "";
my $primary_master_password = "";
my $apache_vip_name = "";
my $ucarp_int_password = "";
my $ucarp_pub_password = "";

my $helper_scripts_path = "/usr/libexec/foss-cloud";
my $remote_helper_scripts_path = $cfg->val("General","remote_helper_script_location");

######################################################################################################
# Constant definitions
######################################################################################################
use constant SUCCESS_CODE                           => 0;
use constant SUCCESS_STRING                         => "The script was executed successfully.";
use constant ERROR_UNDEFINED_CODE                   => 1;
use constant ERROR_UNDEFINED_STRING                 => "The script ended in an undefined state.";
use constant ERROR_NO_NODETYPE_NAME_CODE            => 2;
use constant ERROR_NO_NODETYPE_NAME_STRING          => "No node-type name was passed.";
use constant ERROR_NETWORK_CHECK_FAILED_CODE        => 3;
use constant ERROR_NETWORK_CHECK_FAILED_STRING      => "The node-configuration-check failed.";
use constant ERROR_UNKNOWN_NODETYPE_CODE            => 4;
use constant ERROR_UNKNOWN_NODETYPE_STRING          => "Unknown node-type passed.";
use constant ERROR_NO_SSH_CONNECTION_CODE           => 5;
use constant ERROR_NO_SSH_CONNECTION_STRING         => "Unable to estalbish ssh connection.";
use constant ERROR_SSH_CMD_FAILED_CODE              => 6;
use constant ERROR_SSH_CMD_FAILED_STRING            => "Could not execute ssh command.";
use constant ERROR_RCUPDATE_FAILED_CODE             => 7;
use constant ERROR_RCUPDATE_FAILED_STRING           => "The command rc-update failed.";
use constant ERROR_UNKNOWN_STORAGENODETYPE_CODE     => 8;
use constant ERROR_UNKNOWN_STORAGENODETYPE_STRING   => "Unknown Storage-Node type passed.";
use constant ERROR_PASSWORD_NOT_CREATED_CODE        => 9;
use constant ERROR_PASSWORD_NOT_CREATED_STRING      => "Could not create the password.";
use constant ERROR_DAEMON_START_FAILED_CODE         => 10;
use constant ERROR_DAEMON_START_FAILED_STRING       => "Could not start the desired daemon.";
use constant ERROR_DAEMON_STOP_FAILED_CODE          => 11;
use constant ERROR_DAEMON_STOP_FAILED_STRING        => "Could not stop the desired daemon.";
use constant ERROR_MISSING_DIRECTORY_CODE           => 12;
use constant ERROR_MISSING_DIRECTORY_STRING         => "Neccessary directory missing.";
use constant ERROR_LOADING_LDIF_CODE                => 13;
use constant ERROR_LOADING_LDIF_STRING              => "Could not add LDIF to directory.";
use constant ERROR_UNPACKING_TARBALL_CODE           => 14;
use constant ERROR_UNPACKING_TARBALL_STRING         => "Could not unpack the tarball.";
use constant ERROR_MISSING_FILE_CODE                => 15;
use constant ERROR_MISSING_FILE_STRING              => "Neccessary file missing.";
use constant ERROR_NO_PASSWORD_PASSED_CODE          => 16;
use constant ERROR_NO_PASSWORD_PASSED_STRING        => "Password parameter not specified or empty";
use constant ERROR_DELETE_FILE_CODE                 => 17;
use constant ERROR_DELETE_FILE_STRING               => "Could not delete file";
use constant ERROR_EXECUTE_COMMAND_CODE             => 18;
use constant ERROR_EXECUTE_COMMAND_STRING           => "Could not execute a CLI command";
use constant ERROR_NO_LDAP_CONNECTION_CODE          => 19;
use constant ERROR_NO_LDAP_CONNECTION_STRING        => "Could not establish a connection to the LDAP-Server";
use constant ERROR_NO_LDAP_BIND_CODE                => 20;
use constant ERROR_NO_LDAP_BIND_STRING              => "Could not bind to the LDAP-Server";
use constant ERROR_GLUSTER_PEER_PROBE_FAILED_CODE   => 21;
use constant ERROR_GLUSTER_PEER_PROBE_FAILED_STRING => "The gluster peer probe command did not succeed";
use constant ERROR_CANNOT_CREATE_BACKUP_DIR_CODE    => 22;
use constant ERROR_CANNOT_CREATE_BACKUP_DIR_STRING  => "Cannot create the backup directory /var/virtualization/backup";
use constant ERROR_NETWORK_CONF_MISSING_CODE        => 23;
use constant ERROR_NETWORK_CONF_MISSING_STRING      => "The specified network configuration is not writable";
use constant ERROR_PASSWORD_NOT_FOUND_CODE          => 24;
use constant ERROR_PASSWORD_NOT_FOUND_STRING        => "Could not get all necessary passwords form primary master node";
use constant ERROR_GLUSTER_PEER_STATUS_FAILED_CODE  => 25;
use constant ERROR_GLUSTER_PEER_STATUS_FAILED_STRING => "The gluster peer status command did not succeed";

use constant VIP            => 'vip';
use constant SECONDARY_IP   => 'secondary_ip';
######################################################################################################
# Help text
######################################################################################################
my $help = "\nPlease use pod2text $0 for the online help\n\n";
 
######################################################################################################
# Main Programme
######################################################################################################

openlog($0,"ndelay,pid","local0");

# Check the command line arguments
checkCommandLineArguments();

# Generate a universal unique identifier
my $foss_cloud_uuid = `uuidgen`;

# And remove the newline at the end
chomp($foss_cloud_uuid);

SWITCH: {
  $opts{'node-type'} eq "primary-storage-node" and do {
    $modus = "primary-storage";
    primaryStorageNode();
    last;
  };
  $opts{'node-type'} eq "secondary-storage-node" and do {
    $modus = "secondary-storage";
    secondaryStorageNode();
    last;
  };
  $opts{'node-type'} eq "primary-master-node" and do {
    $modus = "primary-master";
    primaryMasterNode();
    last;
  };
  $opts{'node-type'} eq "secondary-master-node" and do {
    $modus = "secondary-master";
    secondaryMasterNode();
    last;
  };
  $opts{'node-type'} eq "vm-node" and do {
    $modus = "vm-node";
    vmNode();
    last;
  };
  $opts{'node-type'} eq "demo-system" and do {
    $modus = "demo-system";
    demoSystem( $password );
    last;
  };
  $opts{'node-type'} eq "single-server" and do {
    $modus = "single-server";
    singleServer( );
    last;
  };

  # If we reach this point we have a non valid type.
  returnError(ERROR_UNKNOWN_NODETYPE_CODE,ERROR_UNKNOWN_NODETYPE_STRING);
} # End of SWITCH

closelog();


######################################################################################################
# Subroutines
######################################################################################################

######################################################################################################
# checkCommandLineArguments
######################################################################################################
# Description:
#  Check the command line arguments.
######################################################################################################
sub checkCommandLineArguments {
 
  # Check, if help was chosen. If yes, display help and exit
  if ($opts{'help'}){
    print $help;
    exit SUCCESS_CODE;
  } # End of if ($opts{'help'})

  # Check, if the debug modus was chosen.
  if ($opts{'d'}){
    $debug = 1;   # Debug modus: 0: off, 1: on
  } # End of if (opts{'d'})

  # Check, if the dry-run modus was chosen.
  if ($opts{'dry-run'}){
    $dryrun = 1;   # Dry-run modus: 0: off, 1: on
  } # End of if (opts{'dry-run'})
 
  # Check, if a type was passed to the script.
  if ((!$opts{'node-type'}) || ($opts{'node-type'} le "")) {
    returnError(ERROR_NO_NODETYPE_NAME_CODE,ERROR_NO_NODETYPE_NAME_STRING);
  }

  # Check if a password was passed
  if ( $opts{'password'} && $opts{'password'} ne " " )
  {
      # Set the password which will be passed to the demo system method
      $password = $opts{'password'};
  }

  # For the demo-system we need to pass the password by command line
  if ( $opts{'node-type'} eq "demo-system" && !$opts{'password'} )
  {
      returnError(ERROR_NO_PASSWORD_PASSED_CODE,ERROR_NO_PASSWORD_PASSED_STRING);
  }
} # End of sub checkCommandLineArguments


######################################################################################################
# returnError
######################################################################################################
# Description:
#   Returns the error code as a JSON string.
######################################################################################################
sub returnError {
  my $error_code = $_[0];
  my $error_string = $_[1];
  my $error_reason = $_[2];

  # Write the syslog error message.
  syslog("LOG_ERR",$error_string);

  # Create a thing (called $json) that will be used to encode JSON strings
  my $json = JSON::XS->new->utf8->pretty();

  # Print the JSON Message and exit with the proper exit code.
  if($error_reason){
    print $json->encode({
      "Return Code" => $error_code,
      "Return String" => $error_string,
      "Reason" => $error_reason,
    });
  }
  else{
    print $json->encode({
      "Return Code" => $error_code,
      "Return String" => $error_string,
    });
  }
  exit $error_code;

} # End of sub returnError


######################################################################################################
# primaryStorageNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up the first storage-node.
######################################################################################################
sub primaryStorageNode{

  # Display a nice title
  header("First Storage-Node Installation");

  # Asks the user, if the installation should really proceed
  proceed("primary-storage-node");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Configure the ClusterFS deamon
  configureGlusterFS("primary",$localNetworkHash);

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub primaryStorageNode


######################################################################################################
# secondaryStorageNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up the second storage-node.
######################################################################################################
sub secondaryStorageNode{

  # Display a nice title
  header("Second Storage-Node Installation");

  # Asks the user, if the installation should really proceed
  proceed("secondary-storage-node");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # The the user what is happinging
  header("Retrieving remote network configuration ...");

  # Ask the user for the information of the first storage Node.
  my ($host,$user,$password)=askRemoteHostInfo("primary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the first Storage-Node
  my $remoteNetworkHash = checkRemoteNetwork($host,$user,$password);

  # Configure the ClusterFS deamon
  configureGlusterFS("secondary",$localNetworkHash,$remoteNetworkHash);

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub secondaryStorageNode


######################################################################################################
# primaryMasterNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up the primary-master-node.
######################################################################################################
sub primaryMasterNode{

  # Display a nice title
  header("Primary-Master-Node Installation");

  # TBD: Workaround
  #print "Before proceeding, with the Primary-Master-Node Installation, you need to edit the \n";
  #print "sstNode=<your Primary-Master-Nod>,ou=nodes,ou=virtualization,ou=services,dc=foss-cloud,dc=org LDIF:\n";
  #print "  cp /etc/openldap/data/16_primary-master-node.template /etc/openldap/data/16_primary-master-node.ldif\n";
  #print "Now open the copied file and replace the existing values with your setup:\n";
  #print "  vi /etc/openldap/data/16_primary-master-node.ldif\n";
  #print "The values should be self explaining.\n";
  #print "\n";

  # Asks the user, if the installation should really proceed
  proceed("primary-master-node");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Ask for the VIPs
  my @vips = askVIP( $localNetworkHash->{'pub'}->{'domain'} );

  # Add the vips to the network config
  addVIPsToNetworkConfig( @vips );

  # Start with step one and check the network configuration
  $localNetworkHash = checkLocalNetwork();

  # Tell the user, that we need to collect the data of the storage Nodes.
  header("Collecting data from the Storage-Nodes");

  # Ask the user for the information of the first storage Node.
  my ($host1,$user1,$password1)=askRemoteHostInfo("primary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the first Storage-Node
  my $remoteNetworkHash1 = checkRemoteNetwork($host1,$user1,$password1);

  # Ask the user for the information of the second storage Node.
  my ($host2,$user2,$password2)=askRemoteHostInfo("secondary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the second Storage-Node
  my $remoteNetworkHash2 = checkRemoteNetwork($host2,$user2,$password2);

  # Write to the hosts file
  wirteVIPToHosts($localNetworkHash);

  # Start the ksm daemon and add it to the default runlevel
  startDaemon("ksm");
  rcUpdate("ksm","default");

  # Start the ksmtuned daemon and add it to the default runlevel
  startDaemon("ksmtuned");
  rcUpdate("ksmtuned","default");

  # Mount the GlusterFS volume
  mountGlusterFS($remoteNetworkHash1,$remoteNetworkHash2);

  # Unpack virtualization data tarball and test if it's ok
  my $tarball = $cfg->val($modus,"file_tarball_source");
  my $destination = $cfg->val($modus,"file_tarball_destination");
  if ( unpackVirtualizationDataTarball($tarball, $destination) )
  {
      returnError(ERROR_UNPACKING_TARBALL_CODE,ERROR_UNPACKING_TARBALL_STRING);
  }

  # Configure the libvirtd daemon
  configureLibvirt($localNetworkHash);

  # Create the Root CA
  createRootCA();

  # Configure the slapd daemon
  my $unencrypted_password = configureOpenLDAP($localNetworkHash,0,$password);

  # Configure the VM-Manger
  configureVMManager($localNetworkHash,$unencrypted_password);

  # Configure phpLDAPadmin
  configurePhpLDAPadmin($localNetworkHash);

  # Configure the apache2 daemon
  configureApache2($localNetworkHash);

  # Create the certificate for the apache
  createApacheCertificate($localNetworkHash);

  # Configure ucarp
  configureUcarp($localNetworkHash);

  # Start the ucarp for int and pub
  startDaemon("ucarp.pub",5);
  rcUpdate("ucarp.pub","default");
  startDaemon("ucarp.int",5);
  rcUpdate("ucarp.int","default");

  # Configure DHCP
  configureDHCP($localNetworkHash);

  # Start the dhcp daemon and add it to the default runlevel
  startDaemon("dhcpd");
  rcUpdate("dhcpd","default");

  # Configure the fc-brockerd daemon
  configureFcBrokerd($localNetworkHash,$unencrypted_password);

  # Start the daemon and add it to de default runlevel
  startDaemon("fc-brokerd");
  rcUpdate("fc-brokerd","default");

  configureProvBackupKVM($localNetworkHash, $localNetworkHash->{'int'}->{'vip'}, $prov_backup_kvm_unencrypted_password);

  # Create the backup directory symlink
  createBackupDirectorySymlink();

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub primaryMasterNode


######################################################################################################
# secondaryMasterNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up the secondary-master-node.
######################################################################################################
sub secondaryMasterNode{

  # Display a nice title
  header("Secondary-Master-Node Installation");

   # Asks the user, if the installation should really proceed
   proceed("secondary-master-node");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Get the network config from primary master node (we also need to know the 
  # VIPs)
  # Ask the user for the information of the first storage Node.
 ($primary_master_host,
  $primary_master_user,
  $primary_master_password)= askRemoteHostInfo("primary Master-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the first Storage-Node
  my $remoteNetworkHash = checkRemoteNetwork($primary_master_host,$primary_master_user,$primary_master_password);

  # Add the VIPs to the local network
  my @vips = (
                { VIP => $remoteNetworkHash->{'pub'}->{'vip'}, SECONDARY_IP => $remoteNetworkHash->{'pub'}->{'ip'} },
                { VIP => $remoteNetworkHash->{'admin'}->{'vip'}, SECONDARY_IP => $remoteNetworkHash->{'admin'}->{'ip'} },
                { VIP => $remoteNetworkHash->{'data'}->{'vip'}, SECONDARY_IP => $remoteNetworkHash->{'data'}->{'ip'} },
                { VIP => $remoteNetworkHash->{'int'}->{'vip'}, SECONDARY_IP => $remoteNetworkHash->{'int'}->{'ip'} },
             );
  addVIPsToNetworkConfig(@vips);

  # Get the local network again
  $localNetworkHash = checkLocalNetwork();

  # Ask the user for the information of the first storage Node.
  my ($host1,$user1,$password1)=askRemoteHostInfo("primary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the first Storage-Node
  my $remoteNetworkHash1 = checkRemoteNetwork($host1,$user1,$password1);

  # Ask the user for the information of the second storage Node.
  my ($host2,$user2,$password2)=askRemoteHostInfo("secondary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the second Storage-Node
  my $remoteNetworkHash2 = checkRemoteNetwork($host2,$user2,$password2);

  # Start the ksm daemon and add it to the default runlevel
  startDaemon("ksm");
  rcUpdate("ksm","default");

  # Start the ksmtuned daemon and add it to the default runlevel
  startDaemon("ksmtuned");
  rcUpdate("ksmtuned","default");

  # Mount the GlusterFS volume
  mountGlusterFS($remoteNetworkHash1,$remoteNetworkHash2);

  # Configure the libvirtd daemon
  configureLibvirt($localNetworkHash);

  # Create the Root CA
  createRootCA();

  # Configure the openldap directory
  my $unencrypted_password = configureOpenLDAP($localNetworkHash,
                                               $remoteNetworkHash,
                                               $password);

  # Configure the VM-Manger
  configureVMManager($localNetworkHash,$unencrypted_password);

  # Configure phpLDAPadmin
  configurePhpLDAPadmin($localNetworkHash);

  # Configure the apache2 daemon
  configureApache2($localNetworkHash);

  # Create / get the apache certificate
  createApacheCertificate($localNetworkHash);

  # Configure ucarp
  configureUcarp($localNetworkHash);

  # Start the ucarp for int and pub
  startDaemon("ucarp.pub",5);
  rcUpdate("ucarp.pub","default");
  startDaemon("ucarp.int",5);
  rcUpdate("ucarp.int","default");

  # Configure DHCP
  configureDHCP($localNetworkHash);

  # Start the dhcp daemon and add it to the default runlevel
  startDaemon("dhcpd");
  rcUpdate("dhcpd","default");

  # Configure the fc-brockerd daemon
  configureFcBrokerd($localNetworkHash,$fc_brokerd_unencrypted_password);

  configureProvBackupKVM($localNetworkHash, $localNetworkHash->{'int'}->{'vip'}, $prov_backup_kvm_unencrypted_password);

  # Create the backup directory symlink
  createBackupDirectorySymlink();

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub secondaryMasterNode


######################################################################################################
# vmNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up vm-node.
######################################################################################################
sub vmNode{

  # Display a nice title
  header("VM-Node Installation");

  # Asks the user, if the installation should really proceed
  proceed("vm-node");

  # Start with step one and create the demo-system network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Tell the user, that we need to collect the data of the storage Nodes.
  header("Collecting data from the Storage-Nodes");

  # Ask the user for the information of the first storage Node.
  my ($host1,$user1,$password1)=askRemoteHostInfo("primary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the first Storage-Node
  my $remoteNetworkHash1 = checkRemoteNetwork($host1,$user1,$password1);

  # Ask the user for the information of the second storage Node.
  my ($host2,$user2,$password2)=askRemoteHostInfo("secondary Storage-Node","admin",$localNetworkHash->{"admin"}->{"id"});

  # Retreive the network information of the second Storage-Node
  my $remoteNetworkHash2 = checkRemoteNetwork($host2,$user2,$password2);

  # Mount the GlusterFS volume
  mountGlusterFS($remoteNetworkHash1,$remoteNetworkHash2);

  # Configure the libvirtd daemon
  configureLibvirt($localNetworkHash);

  # Start the ksm daemon and add it to the default runlevel
  startDaemon("ksm");
  rcUpdate("ksm","default");

  # Start the ksmtuned daemon and add it to the default runlevel
  startDaemon("ksmtuned");
  rcUpdate("ksmtuned","default");

  # Get the port and protocol:
  my $ldap_protocol;
  my $ldap_port = $cfg->val("openLDAP","port");
  
  if ( $ldap_port == 389 )
  {
    # If port is 389 means unencrypted connection
    $ldap_protocol = "ldap://";
  } else
  {
    # Otherwise we use encrypted connection
    $ldap_protocol = "ldaps://";

  }

  # The LDAP connection
  my $ldap_connection;
  my $ldap_error;
  my $retry = "yes";
  my $ldap_ip;

  # Ask the user for the correct ip as long as he wants and did not enter the
  # correct one
  while( $retry eq "yes" && !$ldap_connection)
  {

      # Ask the user on which IP the LDAP-Server runs
      $ldap_ip = "";

      # Check if it is a correct IP: 
      while( $ldap_ip !~ m/^(\d{1,3}.){3}\d{1,3}$/ )
      {

          # Ask the user for the IP
          print "\n";
          print "Please enter the IP on which the LDAP Server is running / "
               ."listening. This is the IP of the primary-master-node on int-"
               ."interface which is VLAN 130 (default: 10.1.130.13): ";
          chomp($ldap_ip = <STDIN>);

          unless($ldap_ip)
          {
            $ldap_ip = "10.1.130.13";
          }
      }

      print "Trying to connect to ".$ldap_protocol.$ldap_ip."\n";

      # And now try to bind with the user and password to the given IP to test if 
      # everything is correct
      $ldap_connection = Net::LDAP->new( $ldap_protocol.$ldap_ip,
                                      port => $ldap_port,
                                      async    => 0,
                                      #verify => 'require',
                                      #cafile => '/etc/ssl/certs/Swiss_Certificate_Authority.cert.pem',
                                      );
      # Get the error
      $ldap_error = $!;

      # Test if we have a connection
      if ( !$ldap_connection )
      {
        # Connection failed, retry?
        print "Could not connect to ".$ldap_protocol.$ldap_ip." ($ldap_error), "
             ."retry (yes/NO): ";
        chomp( $retry = <STDIN>);

      }

  }    

  my $binddn;
  my ($ldap_crypt, $prov_backup_kvm_unencrypted_password );

  # Test if the connection could be established: 
  if ( $ldap_connection )
  {

    my $bind;
    my $bind_retry = "yes";

    # Try to bind as long as the user wants
    while ( $bind_retry eq "yes" )
    {

        # If yes try to bind:
        # Also ask the user for the password for the user with which the prov-backup-
        # daemon binds to the LDAP
        $binddn = $cfg->val("prov-backup-kvm","ldap_binddn");
        ($ldap_crypt, $prov_backup_kvm_unencrypted_password ) = askForOpenLDAPPassword($binddn, "enter");

        $bind = $ldap_connection->bind($binddn , password => $prov_backup_kvm_unencrypted_password);

        # Was bind successful? 
        if ( $bind->code() == LDAP_SUCCESS )
        {
            # Set bind retry to no
            $bind_retry = "no";
        } else
        {
            # Ask the user if he wants to retry: 
            print "\nCannot bind to ".$ldap_protocol.$ldap_ip." (".$bind->error()
                  .") retry? (yes/NO): ";
            chomp($bind_retry = <STDIN>);
        }

    }

    # Test if bind was successful: 
    if ( $bind->code() != LDAP_SUCCESS )
    {
        # If not return the error
        returnError(ERROR_NO_LDAP_BIND_CODE,ERROR_NO_LDAP_BIND_STRING,$bind->error());
    } else
    {
        # If success we can set up the prov-backup-kvm daemon
        configureProvBackupKVM($localNetworkHash, $ldap_ip, $prov_backup_kvm_unencrypted_password);
    }

  } else
  {
    # If not we can stop with error
    returnError(ERROR_NO_LDAP_CONNECTION_CODE,ERROR_NO_LDAP_CONNECTION_STRING,$ldap_error);
  }

  # Create the backup directory symlink
  createBackupDirectorySymlink();

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub vmNode


######################################################################################################
# demoSystem
######################################################################################################
# Description:
#   Performs the necessary tasks to set up vm-node.
######################################################################################################
sub demoSystem{

  my $password = shift;

  # Display a nice title
  header("Demo-System Installation");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Unpack virtualization storage data tarball and test if it's ok
  my $tarball = $cfg->val($modus,"file_tarball_storage_source");
  my $destination = $cfg->val($modus,"file_tarball_storage_destination");
  if ( unpackVirtualizationDataTarball($tarball,$destination) )
  {
      returnError(ERROR_UNPACKING_TARBALL_CODE,ERROR_UNPACKING_TARBALL_STRING);
  }
#
#
#  # Unpack virtualization iso data tarball if it exists and test if it's ok
#  $tarball = $cfg->val($modus,"file_tarball_iso_source");
#  $destination = $cfg->val($modus,"file_tarball_iso_destination");
#
#  # Check if the tarball exists or not
#  if ( -r $tarball )
#  {
#      # Unpack the tarball and check for success
#      if ( unpackVirtualizationDataTarball($tarball,$destination) )
#      {
#          returnError(ERROR_UNPACKING_TARBALL_CODE,ERROR_UNPACKING_TARBALL_STRING);
#      }
#  } else
#  {
#      # If the tarball is does not exists, tell the user
#      print "Tarball $tarball does not exist\n\n";
#  }

  # Enable the IPv4 forwarding on the demo system
  enableIPv4Forwarding();

  # Configure the libvirtd daemon
  configureLibvirt($localNetworkHash);

  # Configure the slapd daemon
  my $unencrypted_password = configureOpenLDAP($localNetworkHash,0,$password);

  # Configure the VM-Manger
  configureVMManager($localNetworkHash,$unencrypted_password);

  # Configure phpLDAPadmin
  configurePhpLDAPadmin($localNetworkHash);

  # Configure DHCP
  configureDHCP($localNetworkHash);

  # Configure the apache2 daemon
  configureApache2($localNetworkHash);

  # Start the apache
  startDaemon("apache2");
  rcUpdate("apache2","default");

  # Configure the iptables
  configureIPtables($cfg);

  configureProvBackupKVM($localNetworkHash, $localNetworkHash->{'int'}->{'ip'}, $prov_backup_kvm_unencrypted_password);

  # Configure the fc-brockerd daemon
  configureFcBrokerd($localNetworkHash,$unencrypted_password);
  startDaemon("fc-brokerd");
  rcUpdate("fc-brokerd","default");

  # Start and add the PowerDNS recursor to the default runlevel
  startDaemon("precursor");
  rcUpdate("precursor","default");

  # Start the dhcp daemon and add it to the default runlevel
  startDaemon("dhcpd");
  rcUpdate("dhcpd","default");

  # Create the backup directory symlink
  createBackupDirectorySymlink();

  # Remove the firstboot file
  my $first_boot_file = $cfg->val($modus,"file_first_boot");
  unless ( unlink($first_boot_file) )
  {
      returnError(ERROR_DELETE_FILE_CODE,ERROR_DELETE_FILE_STRING,"$first_boot_file: $!");
  } else
  {
      print "File $first_boot_file deleted\n\n";
  }

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub demoSystem



######################################################################################################
# primaryMasterNode
######################################################################################################
# Description:
#   Performs the necessary tasks to set up the primary-master-node.
######################################################################################################
sub singleServer{

  # Display a nice title
  header("Single-Server-Node Installation");

  # Asks the user, if the installation should really proceed
  proceed("single-server-node");

  # Start with step one and check the network configuration
  my $localNetworkHash = checkLocalNetwork();

  # Add the hosts entries
  my $ldapm01 = $localNetworkHash->{'int'}->{'ip'}."\tldapm-01.".$localNetworkHash->{'pub'}->{'domain'};
  my $ldapm = $localNetworkHash->{'int'}->{'ip'}."\tldapm.".$localNetworkHash->{'pub'}->{'domain'};
  system("echo $ldapm01 >> /etc/hosts");
  system("echo $ldapm >> /etc/hosts");

  # Start the ksm daemon and add it to the default runlevel
  startDaemon("ksm");
  rcUpdate("ksm","default");

  # Start the ksmtuned daemon and add it to the default runlevel
  startDaemon("ksmtuned");
  rcUpdate("ksmtuned","default");

  # Unpack virtualization data tarball and test if it's ok
  my $tarball = $cfg->val($modus,"file_tarball_source");
  my $destination = $cfg->val($modus,"file_tarball_destination");
  if ( unpackVirtualizationDataTarball($tarball, $destination) )
  {
      returnError(ERROR_UNPACKING_TARBALL_CODE,ERROR_UNPACKING_TARBALL_STRING);
  }

  # Configure the libvirtd daemon
  configureLibvirt($localNetworkHash);

  # Create the Root CA
  createRootCA();

  # Configure the slapd daemon
  my $unencrypted_password = configureOpenLDAP($localNetworkHash,0,$password);

  # Configure the VM-Manger
  configureVMManager($localNetworkHash,$unencrypted_password);

  # Configure phpLDAPadmin
  configurePhpLDAPadmin($localNetworkHash);

  # Configure the apache2 daemon
  configureApache2($localNetworkHash);

  # Create the certificate for the apache web server
  createApacheCertificate($localNetworkHash);

  # Start the apache2 daemon and add it to the default runlevel
  startDaemon("apache2");
  rcUpdate("apache2","default");

  # Configure DHCP
  configureDHCP($localNetworkHash);

  # Start the dhcp daemon and add it to the default runlevel
  startDaemon("dhcpd");
  rcUpdate("dhcpd","default");

  # Configure the fc-brockerd daemon
  configureFcBrokerd($localNetworkHash,$unencrypted_password);

  # Start the daemon and add it to de default runlevel
  startDaemon("fc-brokerd");
  rcUpdate("fc-brokerd","default");

  configureProvBackupKVM($localNetworkHash, $localNetworkHash->{'int'}->{'vip'}, $prov_backup_kvm_unencrypted_password);

  # Create the backup directory symlink
  createBackupDirectorySymlink();

  # Tell the administrator, that the installation and configuration of this node is complete.
  print "\nCongratulations, you have finished the installation and configuration of this Node!\n\n"

} # End of sub primaryMasterNode

######################################################################################################
# checkLocalNetwork
######################################################################################################
# Description:
#   Checks the local network configuration and tells the user the status of the check
######################################################################################################
sub checkLocalNetwork {
  my $hash;

  header("Retrieving local network configuration ...");

  # Execute the node-configuration-check script and check the return value 
  # and catch the output. 
  my $output = `$helper_scripts_path/node-integration-check --module network`;
  my $errorCode = $? >> 8;

  # check the exit code of the node-configuration-check. If it is different to
  # zero the check failed so we have to report it. 
  if($errorCode == 0){

    $hash = JSON::XS->new->utf8->decode ($output);

    # If the check succeeded we can print out the network configuration.
    if($debug == 1){
      print "Local network configuration is:\n\n$output\n";

      print "Node Name:        ".$hash->{"Node Name"}."\n\n";

      print "Data Domain Name: ".$hash->{"admin"}->{"domain"}."\n";
      print "Data VLAN name:   admin\n";
      print "Data VLAN ID:     ".$hash->{"admin"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"admin"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"data"}->{"domain"}."\n";
      print "Data VLAN name:   data\n";
      print "Data VLAN ID:     ".$hash->{"data"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"data"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"int"}->{"domain"}."\n";
      print "Data VLAN name:   int\n";
      print "Data VLAN ID:     ".$hash->{"int"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"int"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"pub"}->{"domain"}."\n";
      print "Data VLAN name:   pub\n";
      print "Data VLAN ID:     ".$hash->{"pub"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"pub"}->{"ip"}."\n\n";

    } # End of if($debug == 1)
    print "Local network configuration retrieval ok!\n\n";

    # Return the JSON hash
    return $hash;
  }
  else{

    # If we reach this point, it means that the node-configuration-check failed.
    # Report this and also give the reason why the check failed.
    my $reason = JSON::XS->new->utf8->decode ($output);
    returnError(ERROR_NETWORK_CHECK_FAILED_CODE,ERROR_NETWORK_CHECK_FAILED_STRING,$reason->{"Return String"});
  }

} # End of sub checkLocalNetwork


######################################################################################################
# checkRemoteNetwork
######################################################################################################
# Description:
#   Checks the remote network configuration and tells the user the status of the check
######################################################################################################
sub checkRemoteNetwork {
  my ($host,$user,$password)=@_;
  my $hash;
  my $strict_host_key_check;
  
  my $cmd = "$remote_helper_scripts_path/node-integration-check --module network";

  # Check if the known_hosts file exists or not
  if ( -e "~/.ssh/known_hosts" ) {
      
      # If it exists, set the StrictHostKeyChecking option for SSH to yes which
      # means that we check if we connect to the correct host
      $strict_host_key_check = "StrictHostKeyChecking=yes";

  }
  else {

      # If it does not exist, set the StrictHostKeyChecking option to no, which
      # means that we add the host key to the file
      # This is actually not a very good idea, but up to now the only
      # way to ensure that the script completes its tasks
      $strict_host_key_check = "StrictHostKeyChecking=no";

  }

  # Establish the ssh connection to the remote host $host
  my $ssh = Net::OpenSSH->new($host,
                              user => $user,
			      password => $password,
			      master_opts => [-o => $strict_host_key_check],
			      master_stderr_discard => 1 # quiet
                             );

  if($ssh->error){
    returnError(ERROR_NO_SSH_CONNECTION_CODE,ERROR_NO_SSH_CONNECTION_STRING,$ssh->error);
  }

  my $output = $ssh->capture($cmd);

  # check the exit code of the remote node-configuration-check. If it is different to
  # zero the check failed so we have to report it. 
  if(!$ssh->error){

    $hash = JSON::XS->new->utf8->decode ($output);

    # If the check succeeded we can print out the network configuration.
    if($debug == 1){
      print "Network configuration is:\n\n$output\n";

      print "Node Name:        ".$hash->{"Node Name"}."\n\n";

      print "Data Domain Name: ".$hash->{"admin"}->{"domain"}."\n";
      print "Data VLAN name:   admin\n";
      print "Data VLAN ID:     ".$hash->{"admin"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"admin"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"data"}->{"domain"}."\n";
      print "Data VLAN name:   data\n";
      print "Data VLAN ID:     ".$hash->{"data"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"data"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"int"}->{"domain"}."\n";
      print "Data VLAN name:   int\n";
      print "Data VLAN ID:     ".$hash->{"int"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"int"}->{"ip"}."\n\n";

      print "Data Domain Name: ".$hash->{"pub"}->{"domain"}."\n";
      print "Data VLAN name:   pub\n";
      print "Data VLAN ID:     ".$hash->{"pub"}->{"id"}."\n";
      print "Data IP:          ".$hash->{"pub"}->{"ip"}."\n\n";

    } # End of if($debug == 1)
    print "\nRemote network configuration retrieval ok!\n\n";

    # Return the JSON hash
    return $hash;

  }
  else{

    # If we reach this point, it means that the ssh command could not be executed.
    returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
  }

} # End of sub checkRemoteNetwork


######################################################################################################
# mountGlusterFS
######################################################################################################
# Description:
#   Configures the GlusterFS client and mounts it.
######################################################################################################
# Usage:
#   mountGlusterFS($remoteNetworkHash1,$remoteNetworkHash2);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub mountGlusterFS {
    my ($remoteNetworkHash1,$remoteNetworkHash2)=@_;

    my $remoteDataIP1 = $remoteNetworkHash1->{"data"}->{"ip"};
    my $remoteDataIP2 = $remoteNetworkHash2->{"data"}->{"ip"};
    my $fstab_file = $cfg->val($modus,"fstab_file");
    my $gluster_mount_point = $cfg->val($modus,"gluster_mount_point");
    my $gluster_mount_options = $cfg->val($modus,"gluster_mount_options");
    my $gluster_volume_name = $cfg->val("General","gluster_volume_name");
    my $mount_binary = $cfg->val($modus,"mount_binary");
    my $output;
    my $errorCode;
    
    # Configuring the GlusterFS client and mounting it
    header("Configuring the local GlusterFS client and mounting it ...");

    # First part of the string is a newline for a nice look and feel
    my $fstab_string = "\n";
    
    # Then we put a little comment in the file
    $fstab_string .= "# Mounting the glusterfs\n";

    # Then we add the command
    $fstab_string .= "$remoteDataIP1:/$gluster_volume_name $gluster_mount_point";
    $fstab_string .= " glusterfs $gluster_mount_options,backupvolfile-server=";
    $fstab_string .= "$remoteDataIP2 0 0\n";

    # Check if it is a dry-run or not
    if ( !$dryrun )
    {
        # Now add the whole string to the fstab file
        open(FSTAB,">>$fstab_file") || die ("Cannot open $fstab_file for writting");
        print FSTAB $fstab_string;
        close FSTAB;

    } else
    {
        # If dryrun only say what we would do
        print "--dry-run: Would write $fstab_string to $fstab_file\n";
    }

    # Mount the glusterfs
    my $mount_command = "$mount_binary $gluster_mount_point";
    
    # Check if it is a dry-run or not
    if ( !$dryrun )
    {
      # Execute the mount command
      system($mount_command);
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Successfully mounted $gluster_mount_point!\n";
      } else {
        returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
      }

    } else
    {
        print "--dry-run: $mount_command\n";
    }

} # End of sub mountGlusterFS

######################################################################################################
# configureGlusterFS
######################################################################################################
# Description:
#   Configures the GlusterFS Deamon depending on the output of the checkNetwork
#   subroutine. 
######################################################################################################
sub configureGlusterFS {
  my ($type,$localNetworkHash,$remoteNetworkHash)=@_;

  my $localDataIP;
  my $remoteDataIP;
  my $output;
  my $errorCode;
  my $glusterCmd;
  my $errorCodeTwo;
  my $glusterCmdTwo;

  my $gluster_volume_name = $cfg->val("General","gluster_volume_name");

  SWITCH: {
    $type eq "primary" and do {
      header("Configuring GlusterFS on the primary Storage-Node ...");
      $localDataIP = $localNetworkHash->{"data"}->{"ip"};
      print "Local Data IP (used for the primary glusterd daemon): $localDataIP\n";

      last;
    };
    $type eq "secondary" and do {
      header("Configuring GlusterFS on the secondary Storage-Node ...");
      $localDataIP = $localNetworkHash->{"data"}->{"ip"};
      $remoteDataIP = $remoteNetworkHash->{"data"}->{"ip"};
      print "Remote Data IP (used for the primary glusterd daemon): $remoteDataIP\n";
      print "Local Data IP (used for the secondary glusterd daemon): $localDataIP\n";
      last;
    };

    # If we reach this point we have a non valid type.
    returnError(ERROR_UNKNOWN_STORAGENODETYPE_CODE,ERROR_UNKNOWN_STORAGENODETYPE_STRING,"Unknown Storage-Node type ($type) passed to sub configureGlusterFS");
  } # End of SWITCH

  # Start the glusterd daemon
  startDaemon("glusterd");

  # Add the glusterd daemon to the default runlevel
  rcUpdate("glusterd","default");

  # If we are installing the second storage-node, we have some more work to do
  if ($type eq "secondary") {

    # Initial peer and volume configuration 
    print "\n";
    print "Working on the initial peer and volume configuration ...\n";

    # Add the peer node to the trusted storage pool
    print "\n";
    print "Adding the remote storage-node with the IP address $remoteDataIP to the trusted storage pool ...\n";
    if (!$dryrun) {
      print "Executing: gluster peer probe $remoteDataIP ...\n";
      $output = `gluster peer probe $remoteDataIP`;
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Added the gluster peer with the IP address $remoteDataIP successfully!\n";
      } else {

        # If there was an error, it is possible that the gluster was not yet 
        # fully started, so wait for 5 seconds and try again
        print "Could not add gluster peer, try again in 5 seconds!\n";
        sleep 5;
        $output = `gluster peer probe $remoteDataIP`;
        $errorCode = $? >> 8;

        if($errorCode == 0)
        {
            print "Added the gluster peer with the IP address $remoteDataIP successfully!\n";
        } else
        {
            returnError(ERROR_GLUSTER_PEER_PROBE_FAILED_CODE,ERROR_GLUSTER_PEER_PROBE_FAILED_STRING,$output);
        }

      }
    } else {
      print "--dry-run: gluster peer probe $remoteDataIP\n";
    } # End of if (!$dryrun)

    # Verify the peer status
    print "\n";
    print "Verifying the peer status ...\n";

    $output = `gluster peer status`;
    $errorCode = $? >> 8;

    # Parse the output to see wether or not the peers state is "Peer in Cluster (Connected)"
    my $retry_status = 0;
    if ( $errorCode == 0 && $output =~ m/State\:\s(.+)\n/ )
    {
        # Check if the matched part is "Peer in Cluster (Connected)", then everything is ok
        if ( $1 ne "Peer in Cluster (Connected)" )
        {
            print "Peer is not yet in cluster, retry in 5 seconds\n";
            $retry_status = 1;
        }
    } else
    {
        print "The command \"gluster peer status\" did not return a state value";
        print ", retry in 5 seconds\n";
        $retry_status = 1;
    }
    
    # If we need to re-execute the gluster peer status command, wait 5 seconds and retry
    if ( $retry_status )
    {
        sleep 5;
        $output = `gluster peer status`;
        $errorCode = $? >> 8;

        # Parse the output to see wether or not the peers state is "Peer in Cluster (Connected)"
        if ( $errorCode == 0 && $output =~ m/State\:\s(.+)\n/ )
        {
            # Check if the matched part is "Peer in Cluster (Connected)", then everything is ok
            if ( $1 ne "Peer in Cluster (Connected)" )
            {
                returnError(ERROR_GLUSTER_PEER_STATUS_FAILED_CODE,ERROR_GLUSTER_PEER_STATUS_FAILED_STRING );
            }
        } else
        {
            returnError(ERROR_GLUSTER_PEER_STATUS_FAILED_CODE,ERROR_GLUSTER_PEER_STATUS_FAILED_STRING );
        } 
    }

    # Creating the distributed replicated volume
    print "Creating the distributed replicated volume ...\n";
    if (!$dryrun) {
      print "Executing: gluster volume create $gluster_volume_name replica 2 transport tcp $localDataIP:/var/data/gluster-volume-01/fc-storage $remoteDataIP:/var/data/gluster-volume-01/fc-storage ...\n";
      $output = `gluster volume create $gluster_volume_name replica 2 transport tcp $localDataIP:/var/data/gluster-volume-01/fc-storage $remoteDataIP:/var/data/gluster-volume-01/fc-storage`;
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Creating the distributed replicated volume successfully!\n";
      } else {
        returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
      }
    } else {
      print "--dry-run: gluster volume create $gluster_volume_name replica 2 transport tcp $localDataIP:/var/data/gluster-volume-01/fc-storage $remoteDataIP:/var/data/gluster-volume-01/fc-storage\n";
    } # End of if (!$dryrun)


    # Configure the distributed replicated volume
    print "Configuring the distributed replicated volume ...\n";
    if (!$dryrun) {
      $glusterCmd = "gluster volume set $gluster_volume_name nfs.disable On";
      print "Executing: $glusterCmd ...\n";
      $output = `$glusterCmd`;
      $errorCode = $? >> 8;


      # Permit access from unprivileged source ports for direct gluster file access via the API
      $glusterCmdTwo = "gluster volume set $gluster_volume_name server.allow-insecure On";
      print "Executing: $glusterCmdTwo ...\n";
      $output = `$glusterCmdTwo`;
      $errorCodeTwo = $? >> 8;


      if ($errorCode == 0 && $errorCodeTwo == 0) {
        print "Configured the distributed replicated volume successfully!\n";
      } else {
        returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
      }
    } else {
      print "--dry-run: $glusterCmd\n";
    } # End of if (!$dryrun)


    # Start the volume
    print "\n";
    print "Trying to start the newly created volume ...\n";
    if (!$dryrun) {
      print "Executing: gluster volume start $gluster_volume_name ...\n";
      $output = `gluster volume start $gluster_volume_name`;
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Started the newly created volume successfully!\n";
      } else {
        returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
      }
    } else {
      print "--dry-run: gluster volume start $gluster_volume_name\n";
    } # End of if (!$dryrun)


    # Display the volume information
    print "Displaying the volume information ...";
    $output = `gluster volume info`;
    $errorCode = $? >> 8;

    if($errorCode == 0) {
      print "$output";
    } else {
      returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
    } # End of if($errorCode == 0)

  } # End of if ($type == "secondary")

} # End of sub configureGlusterFS


######################################################################################################
# askRemoteHostInfo
######################################################################################################
# Description:
#   Asks the user for several informaion (IP,username,password) concerning the remote host
######################################################################################################
# Usage:
#   ($host,$user,$password)=askRemoteHostInfo("first Storage-Node","admin",$hash->{"admin"}->{"id"});
######################################################################################################
# Return Values:
#   ($IP,$user,$password)
######################################################################################################
sub askRemoteHostInfo {

  my ($server_type,$segment,$vlan_id,$hash)=@_;

  # Define default var later used for user input
  my $IP = "";
  my $user = "";
  my $password = "";
  my $default_ip = "0.0.0.0";

  print "Please enter the following information for the $server_type with the OpenSSH daemon listening on the VLAN with the name '$segment' and with the VLAN ID '$vlan_id':\n\n";
  
  # Check if it is a primary or secondary storage node and set the default ip 
  # accordingly

  SWITCH: {
    $server_type eq "primary Storage-Node" and do {
      $default_ip = "10.1.110.11";
      last;
    };
    $server_type eq "secondary Storage-Node" and do {
      $default_ip = "10.1.110.12";
      last;
    };
    $server_type eq "primary Master-Node" and do {
      $default_ip = "10.1.110.13";
      last;
    };
  };

  # Ask for the IP address and save it, we check if it is a real IP, if not ask
  # again until we have a real IP
  while($IP !~ m/^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$/){
    print "IP address (default: $default_ip): ";
    chomp($IP = <STDIN>);

    # If no ip was specified, take default_ip
    unless ( $IP )
    {
        $IP = $default_ip;
    }

  }

  # Ask for the username and save it
  print "Username (default: root): ";
  chomp($user = <STDIN>);

  # If no user was specified, take default one (root)
  unless($user){
    $user = "root";
  }

  # Ask for the users password
  print "Password for $user: ";
  
  # Disable the echo on the terminal, so noone can see your top secret password
  system('stty','-echo');
  chomp($password = <STDIN>);
  # Enable the echo on the terminal for all following output 
  system('stty','echo');

  # Print out a newline, for esthetical reasons only
  print "\n";

  return ($IP,$user,$password);

} # End of sub askRemoteHostInfo


######################################################################################################
# startDaemon
######################################################################################################
# Description:
#   Starts the desired daemon.
######################################################################################################
# Usage:
#   startDaemon($daemon,$delay);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub startDaemon {
  my ($daemon, $delay)=@_;
  my $n;
  my $output;
  my $errorCode;

  print "\nStarting the daemon $daemon ...\n";

  # Check, if the daemon isn't already running in the desired runlevel.
  $output = `/etc/init.d/$daemon status  2>&1`;

  if ($output =~ "started") {
    print "The daemon $daemon is already running, restarting...\n";

    restartDaemon($daemon,$delay);

  } else {

    # Test if the daemon crashed
    if ( $output =~ "crashed"){
        
        # If yes first zap it
        if ( !$dryrun ) {
            print "Executing: /etc/init.d/$daemon zap...\n";
            system("/etc/init.d/$daemon zap");
        } else {
             print "--dry-run: /etc/init.d/$daemon zap\n";
        }
    }

    if (!$dryrun) {
      print "Executing: /etc/init.d/$daemon start...\n";
      system("/etc/init.d/$daemon start");
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Started $daemon successfully!\n";
        unless ($delay) {
          $delay = 0;
        } # End of unless ($delay)
        for ($n =0; $n < $delay; $n++) {
          print ".";
          sleep(1);
        } # End of for ($n =0; $n < $delay; $n++)
      } else {
        returnError(ERROR_DAEMON_START_FAILED_CODE,ERROR_DAEMON_START_FAILED_STRING,"Could not start the daemon $daemon.");
      }
    } else {
      print "--dry-run: /etc/init.d/$daemon start\n";
    }
  }

} # End of sub startDaemon


######################################################################################################
# stopDaemon
######################################################################################################
# Description:
#   Stops the desired daemon (if running).
######################################################################################################
# Usage:
#   stopDaemon($daemon);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub stopDaemon {
  my ($daemon)=@_;
  my $output;
  my $errorCode;

  print "\nStopping the daemon $daemon ...\n";

  # Check, if the daemon is running.
  $output = `/etc/init.d/$daemon status`;

  if ($output =~ "started") {
    if (!$dryrun) {
      print "Executing: /etc/init.d/$daemon stop...\n";
      system("/etc/init.d/$daemon stop");
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Stopped $daemon successfully!\n";
      } else {
        returnError(ERROR_DAEMON_STOP_FAILED_CODE,ERROR_DAEMON_STOP_FAILED_STRING,"Could not stop the daemon $daemon.");
      }
    } else {
      print "--dry-run: /etc/init.d/$daemon stop\n";
    }
  } else {
     print "The daemon $daemon is not running, doing nothing.\n";
  } # End of 

} # End of sub stopDaemon


######################################################################################################
# restartDaemon
######################################################################################################
# Description:
#   Restarts the desired daemon.
######################################################################################################
# Usage:
#   restartDaemon($daemon,$delay);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub restartDaemon {
  my ($daemon, $delay)=@_;

  # Test if the daemon is the mount_glusterFS_daemon, this one we do not have to 
  # restart
  # 
  # BST old version 
  # if ( $daemon eq $cfg->val($modus,"mount_glusterFS_daemon") )
  if ( $daemon eq $cfg->val("General","mount_glusterFS_daemon") )
  {
      print "We do not have to restart the daemon $daemon\n";
      return;
  }

  # Test if a reaload is sufficient
  if ( $daemon eq "libvirtd" )
  {
      # Reload is enough
      print "Reloading daemon $daemon...\n";
      if ( !$dryrun )
      {
        system("/etc/init.d/$daemon reload");
      } else
      {
          print "--dry-run /etc/init.d/$daemon reload\n";
      }

      return;
  }

  print "\nRestarting the daemon $daemon ...\n";

  stopDaemon($daemon);

  startDaemon($daemon,$delay);

} # End of sub restartDaemon

######################################################################################################
# rcUpate
######################################################################################################
# Description:
#   Adds the desired daemon to the desired runlevel.
######################################################################################################
# Usage:
#   rcUpdate($daemon,$runlevel);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub rcUpdate {
  my ($daemon,$runlevel)=@_;
  my $output;
  my $errorCode;

  print "\nAdding the daemon $daemon to the runlevel $runlevel ...\n";

  # Check, if the daemon isn't already running in the desired runlevel.
  $output = `rc-update show $runlevel`;

  if ($output =~ $daemon) {
    print "The daemon $daemon is already in the runlevel $runlevel, doing nothing.\n";
  } else {
    if (!$dryrun) {
      print "Executing: rc-update add $daemon $runlevel ...\n";
      $output = `rc-update add $daemon $runlevel`;
      $errorCode = $? >> 8;

      if($errorCode == 0) {
        print "Added $daemon successfully to runlevel $runlevel!\n";
      } else {	
        returnError(ERROR_RCUPDATE_FAILED_CODE,ERROR_RCUPDATE_FAILED_STRING,"Could not add daemon $daemon to runlevel $runlevel.");
      }
    } else {
      print "--dry-run: rc-update add $daemon $runlevel\n";
    }
  } 

} # End of sub rcUpdate


######################################################################################################
# configureLibvirt
######################################################################################################
# Description:
#   Configures the libvirtd daemon on the local host.
######################################################################################################
# Usage:
#   configureLibvirt($localNetworkHash);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub configureLibvirt {
  my ($localNetworkHash)=@_;
  my $file = $cfg->val($modus,"configure_libvirt_file");
  my @output;
  my $error = 1;
  my $localIntIP = $localNetworkHash->{"int"}->{"ip"};

  # Nicer Output
  print "\n";

  # Configuring the libvirtd daemon
  header("Configuring the libvirtd daemon ...");

  # The file /etc/conf.d/libvirtd doesn't need to be modified

  # Working on the file /etc/libvirt/libvirtd.conf
  print "Working on $file ...\n";

  # Replacing #listen_addr = "127.0.0.1" with listen_addr = "$localIntIP"
  open(FILE,$file) || die("Could not open $file for reading.");
  @output = <FILE>;
  close FILE;

  my $line;
  foreach $line (@output) {
    if ($line =~ "^#listen_addr") { 
      print  "Found:          $line";
      $line =~ s/\#listen_addr = .*/listen_addr = "$localIntIP"/g;
      print "Replacing with: listen_addr = \"$localIntIP\"\n";
      $error = 0;
    } elsif ($line =~ "^listen_addr") { 
      print  "Found:          $line";
      $line =~ s/listen_addr = .*/listen_addr = "$localIntIP"/g;
      print "Replacing with: listen_addr = \"$localIntIP\"\n";
      $error = 0;
    } # End of if ($line =~ "listen_addr")
  } # End of foreach $line (@output)

  if (!$dryrun) {
    print "\n";
    print "Writing 'listen_addr = \"$localIntIP\"' to the file $file ...\n";
    open(FOUT,">$file") || die("Could not open $file for writing.");
    foreach $line (@output) {
      print FOUT $line;
    } # End of foreach $line (@output)
    close FOUT;
  } else {
    print "\n";
    print "--dry-run: Would write 'listen_addr = \"$localIntIP\"' to the file $file!\n";
  } # End of if (!$dryrun)

  # Start the libvirtd daemon
  startDaemon("libvirtd");

  # Add the libvirtd daemon to the default runlevel
  rcUpdate("libvirtd","default");

} # End of sub configureLibvirt


######################################################################################################
# Description:
#   Configures the slapd daemon on the local host.
######################################################################################################
# Usage:
#   configureOpenLDAP($localNetworkHash);
######################################################################################################
# Return Values:
#   $unencrypted_password : The unencrypted OpenLDAP Manager password.
######################################################################################################
sub configureOpenLDAP {
  my ($localNetworkHash,$remoteNetworkHash,$password)=@_;

  # Retake the modus, we need it to deal with the ldifs later on
  my $local_modus = $modus;

  # If the modus is demo-system, we can do the same as for a primary-master, so
  # overwrite the local_modus, so we can perform the same actions with the same
  # templates (there is only one little exeption, but to handle this we stil
  # the original $modus
  if ( $modus eq "demo-system" || $modus eq "single-server" )
  {
      $local_modus = "primary-master";
  }

  my $uid_root = $cfg->val("General","uid_root"); # root
  my $gid_root = $cfg->val("General","gid_root"); # root
  my $uid_ldap = $cfg->val("General","uid_ldap"); # ldap
  my $gid_ldap = $cfg->val("General","gid_ldap"); # ldap
  my $directory_openldap = $cfg->val("General","directory_openldap");
  my $directory_acl      = $directory_openldap.$cfg->val("General","directory_acl");;
  my $directory_data     = $directory_openldap.$cfg->val("General","directory_data");;
  my $directory_schema   = $directory_openldap.$cfg->val("General","directory_schema");;
  my $directory_ssl      = $directory_openldap.$cfg->val("General","directory_ssl");;
  my $directory_hdb_data = $cfg->val("General","directory_hdb_data");
  my $directory_confd    = $cfg->val("General","directory_confd");
  my $file_slapd         = $directory_confd.$cfg->val("General","file_slapd");
  my $file_ldap_conf     = $directory_openldap.$cfg->val("General","file_ldap_conf");
  my $file_slapd_conf    = $directory_openldap.$cfg->val("General","file_slapd_conf");
  my $file_00_directory                              = $directory_data."/00_directory-init.ldif";
  my $file_01_administration_nextfreeuid             = $directory_data."/01_nextfreeuid-administration.ldif";
  my $file_02_group_mapping_administration           = $directory_data."/02_group_mapping-administration.ldif";
  my $file_02_administration_services_template       = $directory_data."/02_services-administration.template-$local_modus";
  my $file_02_administration_services                = $directory_data."/02_services-administration.ldif";
  my $file_03_reseller                               = $directory_data."/03_reseller.ldif";
  my $file_04_customers                              = $directory_data."/04_customers.ldif";
  my $file_05_people                                 = $directory_data."/05_people.ldif";
  my $file_05_people_template                        = $directory_data."/05_people.template-primary-master";
  my $file_06_groups                                 = $directory_data."/06_groups.ldif";
  my $file_06_services_virtualization                = $directory_data."/06_services_virtualization.ldif";
  my $file_07_authentication_services_virtualization_template = $directory_data."/07_authentication_services_virtualization.template-$local_modus";
  my $file_07_authentication_services_virtualization = $directory_data."/07_authentication_services_virtualization.ldif";
  my $file_08_configuration_services_virtualization_template = $directory_data."/08_configuration_services_virtualization.template-$local_modus";
  my $file_08_configuration_services_virtualization  = $directory_data."/08_configuration_services_virtualization.ldif";
  my $file_09_networks_services_virtualization_template      = $directory_data."/09_networks_services_virtualization.template-$local_modus";
  my $file_09_networks_services_virtualization       = $directory_data."/09_networks_services_virtualization.ldif";
  my $file_10_nodes_services_virtualization          = $directory_data."/10_nodes_services_virtualization.ldif";
  my $file_11_storage_services_virtualization        = $directory_data."/11_storage_services_virtualization.ldif";
  my $file_12_vm_profiles_services_virtualization    = $directory_data."/12_vm-profiles_services_virtualization.ldif";
  my $file_14_vm_pools_services_virtualization       = $directory_data."/14_vm-pools_services_virtualization.ldif";
  my $file_14_vm_pools_services_virtualization_template  = $directory_data."/14_vm-pools_services_virtualization.template-$local_modus";
  my $file_15_vms_services_virtualization            = $directory_data."/15_vms_services_virtualization.ldif";
  my $file_16_primary_master_node                    = $directory_data."/16_primary-master-node.ldif";
  my $file_16_primary_master_node_template           = $directory_data."/16_primary-master-node.template-$local_modus";
  my $file_16_secondary_master_node                  = $directory_data."/16_secondary-master-node.ldif";
  my $file_16_secondary_master_node_template         = $directory_data."/16_secondary-master-node.template-$local_modus";
  my $file_17_ranges_networks_services_virtualization = $directory_data."/17_ranges_networks_services_virtualization.ldif";
  my $file_18_services_monitoring                    = $directory_data."/18_services_monitoring.ldif";
  my $file_23_roles                                  = $directory_data."/23_roles.ldif";
  my $file;
  my $line;
  my $unencrypted_password;
  my @output;
  my $error = 1;
  my $localIntIP = $localNetworkHash->{"int"}->{"ip"};
  my $ntp_conf_file = $cfg->val("General","ntp_conf_file");
  my $dns_conf_file = $cfg->val("General","dns_conf_file");
  my $int_vip = $localNetworkHash->{"int"}->{"vip"};
  my @sar_commands;
  my @ntp_hosts = ();
  my @dns_hosts = ();
  my $dns_host_string = "";
  my $ntp_host_string = "";
  my $ldap_server;

  # Check if the modus is demo-system, if yes change the vip to the internal 
  # interface ip
  $int_vip = $localIntIP if ( $modus eq "demo-system" || $modus eq "single-server");

  # Check what is the ldap server name
  if ( $modus eq "primary-master" || $modus eq "single-server" )
  {
    $ldap_server = "ldapm-01.".$localNetworkHash->{"pub"}->{"domain"};
  } elsif ( $modus eq "secondary-master" )
  {
    $ldap_server = "ldapm-02.".$localNetworkHash->{"pub"}->{"domain"};
  } elsif ( $modus eq "demo-system" )
  {
    $ldap_server = $localIntIP;
  } 

  # Used for commands later
  my $search;
  my $replace;

  # Create the certificate for the LDAP 
  createLDAPCertificate($localNetworkHash) unless ( $modus eq "demo-system" );

  # Nicer Output
  print "\n";

  # Configuring the slapd daemon
  header("Configuring the slapd daemon ...");

  # Make sure, that the OpenLDAP daemon slapd is not running
  stopDaemon("slapd");

  # Setting the proper permisions on the openldap directory
  print "\n";
  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0755,$directory_openldap);

  ##############################################################################
  ### Working on the file /etc/openldap/ldap.conf if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" || $local_modus eq "secondary-master" )
  {
      # Working on the file /etc/openldap/ldap.conf
      print "\n";
      print "Working on $file_ldap_conf ...\n";

      # Replace:
      # URI             ldap://127.0.0.1:389
      # Or:
      # URI             <FOSS-CLOUD-LDAP-VIP-URI>
      # With:
      # URI             ldap://$localIntIP:389

      # Test if the file exists and is readable
      unless ( -r $file_ldap_conf )
      {
          returnError(ERROR_MISSING_FILE_CODE,
                      ERROR_MISSING_FILE_STRING,
                      "Could not open $file_ldap_conf for reading");
      }

      open(FILE,$file_ldap_conf);
      @output = <FILE>;
      close FILE;

      # Create the replace string 
      my $replace_string;
      my $cert_file;
      my $req_cert;
      if ( $modus eq "demo-system" )
      {
        # LDAP
        $replace_string = "URI             ldap:\/\/$int_vip:389";
        $cert_file = "#TLS_CACERT <FOSS-CLOUD-LDAP-CA-CERTIFICATE-FILE>";
        $req_cert = "#TLS_REQCERT demand"; 
      } else
      {
        # LDAPS
        $replace_string = "URI             ldaps:\/\/$int_vip:636";
        my $ldap_cert_name;
        $ldap_cert_name = "ldapm-01." if ( $modus eq "primary-master" || $modus eq "single-server" );
        $ldap_cert_name = "ldapm-02." if ( $modus eq "secondary-master");
        $ldap_cert_name .= $localNetworkHash->{'pub'}->{'domain'}.".cert.pem";
        $cert_file = "TLS_CACERT /etc/ssl/certs/FOSS-Cloud_CA.cert.pem";
        $req_cert = "TLS_REQCERT demand"; 
      }

      foreach $line (@output) {
        if ($line =~ "^URI") {
          print "Found:          $line";
          $line =~ s/URI.*/$replace_string/g;
          print "Replacing with: $replace_string\n";
          $error = 0;
        } # End of if ($line =~ "listen_addr")

        if ($line =~ m/<FOSS-CLOUD-LDAP-CA-CERTIFICATE-FILE>/ ) {
          print "Found:          $line";
          $line = $cert_file."\n";
          print "Replacing with: $cert_file\n";
          $error = 0;
        } # End of if ($line =~ "listen_addr")

        if ($line =~ m/#TLS_REQCERT\sdemand/) {
          print "Found:          $line";
          $line = $req_cert."\n";
          print "Replacing with: $req_cert\n";
          $error = 0;
        } # End of if ($line =~ "listen_addr")

      } # End of foreach $line (@output)

      if (!$dryrun) {
        print "Writing:        $replace_string\n";
        print "To the file:    $file_ldap_conf\n";
        open(FOUT,">$file_ldap_conf") || die("Could not open $file_ldap_conf for writing.");
        foreach $line (@output) {
          print FOUT $line;
        } # End of foreach $line (@output)
        close FOUT;
      } else {
        if ($debug) {
          foreach $line (@output) {
            print $line;
          } # End of foreach $line (@output)
        } # End of if ($debug)
        print "--dry-run: Would write '$replace_string' to the file $file_ldap_conf!\n";
      } # End of if (!$dryrun)

      # Setting the proper permisions on the file /etc/openldap/ldap.conf ...
      setSingleFilePermissions("file",$uid_root,$gid_ldap,0644,$file_ldap_conf);
  } # End of if ( $local_modus eq "primary_master" )
  # End of working on /etc/openldap/ldap.conf

  ##############################################################################
  ### Working on the file /etc/openldap/slapd.conf if needed by $modus
  ##############################################################################

  # Generate a passwor for the syncrepl user
  my $syncrepl_password;
  if ( $local_modus eq "primary-master" )
  {
    $syncrepl_password = chars(8,8);
  }

  if ( $local_modus eq "primary-master" || $local_modus eq "secondary-master")
  {
      # Working on the file /etc/openldap/slapd.conf
      print "\n";
      print "Working on $file_slapd_conf ...\n";

      # If the password was passed, i.e. specified in command line args we don't
      # need to ask the user, just create a crypted one. But if the password was not
      # specified in command line args, ask the user to enter a password

      my $openldap_binddn = $cfg->val("openLDAP","binddn");

      # Get the syncrepl provider
      my $syncrepl_provider;
      # Check if ldaps or ldap
      if ( $modus eq "demo-system" )
      {
          # LDAP
          $syncrepl_provider = "ldap://";
      } else
      {
          # LDAPS
          $syncrepl_provider = "ldaps://";
      }

      # Check what modus we have
      if ( $local_modus eq "primary-master" )
      {
        # Its the secondary ip from the int-interface (we asked this information 
        # at the start of the script when asking for the VIPs)

        $syncrepl_provider .= $cfg->val("primary-master","ldap_domaim_name_for_hosts_file").".".$localNetworkHash->{'pub'}->{'domain'};
        $syncrepl_provider .= "127.0.0.2" if ( $modus eq "demo-system" );

      } else
      {
        # If its the secondary storage node, its the remote networks int ip
        $syncrepl_provider .= $cfg->val("secondary-master","ldap_domaim_name_for_hosts_file").".".$localNetworkHash->{'pub'}->{'domain'};
        ($syncrepl_password, 
         $dhcp_unencrypted_password,
         $prov_backup_kvm_unencrypted_password,
         $fc_brokerd_unencrypted_password,
         $apache_vip_name,
         $ucarp_pub_password,
         $ucarp_int_password ) = getRemoteConfiguration();

        # Write to the hosts file
        wirteVIPToHosts($localNetworkHash);

      }


      unless ( defined($password) && $password ne "" )
      {
          # Ask the user for the Manager password
          if ( $modus eq "primary-master" )
          {
            ($password,$unencrypted_password) = askForOpenLDAPPassword($openldap_binddn,"define");
          } else 
          {
            ($password,$unencrypted_password) = askForOpenLDAPPassword($openldap_binddn,"enter");
          }
      } else
      {
          # Create a crypted version of the password specified in command line args
          $unencrypted_password = $password;
          $password = `/usr/sbin/slappasswd -s '$unencrypted_password'`;
          my $errorCode = $? >> 8;

          chomp($password);

          if($errorCode != 0) {
              returnError(ERROR_PASSWORD_NOT_CREATED_CODE,ERROR_PASSWORD_NOT_CREATED_STRING,"Could not encrypt the password with slappasswd.");
          } # End of if($errorCode != 0)
      }

      # Replace:
      # rootpw          {SSHA}0vML7DliNHZWrK9pok8UQpPhyPe9iNKu
      # Or:
      # rootpw          <FOSS-CLOUD-SLAPD-ROOT-PW>
      # With:
      # rootpw          {SSHA}McZMZiKDM5/EpeexPxG4qOojndoJeM2D

      # Test if the file exists and is readable
      unless ( -r $file_slapd_conf )
      {
          returnError(ERROR_MISSING_FILE_CODE,
                      ERROR_MISSING_FILE_STRING,
                      "Could not open $file_slapd_conf for reading");
      }

      open(FILE,$file_slapd_conf);
      @output = <FILE>;
      close FILE;

      foreach $line (@output) {
        if ($line =~ "^rootpw") {
          print "Found:          $line";
          $line =~ s/rootpw.*/rootpw          $password/g;
          print "Replacing with: rootpw          $password\n";
          $error = 0;
        } # End of if ($line =~ "^rootpw")
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-SERVER-ID>/ )
        {
            # Replace the Serverid
            my $server_id = $cfg->val($modus,"openldap_server_id");
            $line =~ s/<FOSS-CLOUD-SLAPD-SERVER-ID>/$server_id/;
            print "Replacing <FOSS-CLOUD-SLAPD-SERVER-ID> with: $server_id\n";
            $error = 0;
        }
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-SYNCREPL-RID>/ )
        {
            # Replace the sycnrepl rid
            my $syncrepl_rid = $cfg->val($modus,"syncrepl_rid");
            $line =~ s/<FOSS-CLOUD-SLAPD-SYNCREPL-RID>/$syncrepl_rid/;
            print "Replacing <FOSS-CLOUD-SLAPD-SERVER-ID> with: $syncrepl_rid\n";
            $error = 0;
        }
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-SYNCREPL-PROVIDER>/ )
        {
            # Replace the syncrepl provider
            $line =~ s/provider=.+$/provider=$syncrepl_provider/;
            # TODO change the line above, just replace <FOSS-CLOUD-SLAPD-SYNCREPL-PROVIDER>
            print "Replacing <FOSS-CLOUD-SLAPD-SYNCREPL-PROVIDER> with: $syncrepl_provider\n";
            $error = 0;
        }
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-SYNCREPL-CREDENTIALS>/ )
        {
            # Replace the syncrepl password
            $line =~ s/<FOSS-CLOUD-SLAPD-SYNCREPL-CREDENTIALS>/$syncrepl_password/;
            print "Replacing <FOSS-CLOUD-SLAPD-SYNCREPL-CREDENTIALS> with: $syncrepl_password\n";
            $error = 0;
        }
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-CERTIFICATE>/ && $modus ne "demo-system" )
        {
            # Replace the syncrepl password
            $line = "TLSCertificateFile     /etc/openldap/ssl/$ldap_server.cert.pem\n";
            print "Replacing <FOSS-CLOUD-SLAPD-CERTIFICATE> with: $ldap_server.cert.pem\n";
            $error = 0;
        }
        if ( $line =~ m/<FOSS-CLOUD-SLAPD-KEY>/ && $modus ne "demo-system" )
        {
            # Replace the syncrepl password
            $line = "TLSCertificateKeyFile     /etc/openldap/ssl/keys/$ldap_server.key.pem\n";
            print "Replacing <FOSS-CLOUD-SLAPD-KEY> with: $ldap_server.key.pem\n";
            $error = 0;
        }

        if ( $line =~ m/<FOSS-CLOUD-SLAPD-CA-CERTIFICATE-FILE>/ && $modus ne "demo-system" )
        {
            # Replace the syncrepl password
            $line = "TLSCACertificateFile   /etc/ssl/certs/FOSS-Cloud_CA.cert.pem\n";
            print "Replacing <FOSS-CLOUD-SLAPD-CA-CERTIFICATE-FILE> with: /etc/ssl/certs/FOSS-Cloud_CA.cert.pem\n";
            $error = 0;
        }


      } # End of foreach $line (@output)

      if (!$dryrun) {
        print "Writing:        rootpw          $password\n";
        print "To the file:    $file_slapd_conf\n";
        open(FOUT,">$file_slapd_conf") || die("Could not open $file_slapd_conf for writing.");
        foreach $line (@output) {
          print FOUT $line;
        } # End of foreach $line (@output)
        close FOUT;
      } else {
        if ($debug) {
          foreach $line (@output) {
            print $line;
          } # End of foreach $line (@output)
        } # End of if ($debug)
        print "--dry-run: Would write 'rootpw          $password' to the file $file_slapd_conf!\n";
      } # End of if (!$dryrun)

      # Setting the proper permisions on the file /etc/openldap/slapd.conf ...
      setSingleFilePermissions("file",$uid_root,$gid_ldap,0640,$file_slapd_conf);

  } #   if ( $local_modus eq "primary-master" )
  #  End of working on the file /etc/openldap/slapd.conf


  if ( ( $local_modus eq "primary-master" ) || ( $local_modus eq "vm-node" ) )
  {
      # If the password was passed, i.e. specified in command line args we don't
      # need to ask the user, just create a crypted one. But if the password was not
      # specified in command line args, ask the user to enter a password
      print "\n";

      my $openldap_binddn = $cfg->val("prov-backup-kvm","ldap_binddn");

      # Remember we don't want the user to set anythign so just set the password
      # for the backup deamon to the password that was passed
      $prov_backup_kvm_unencrypted_password = $unencrypted_password;
      $prov_backup_kvm_password = `/usr/sbin/slappasswd -s '$prov_backup_kvm_unencrypted_password'`;
      chomp( $prov_backup_kvm_password );

      unless ( defined($prov_backup_kvm_password) && $prov_backup_kvm_password ne "" )
      {
          # Ask the user for the prov-backup-kvm password
          if ( $modus eq "primary_master" )
          {
            ($prov_backup_kvm_password,$prov_backup_kvm_unencrypted_password) = askForOpenLDAPPassword($openldap_binddn,"define");
          } else
          {
            ($prov_backup_kvm_password,$prov_backup_kvm_unencrypted_password) = askForOpenLDAPPassword($openldap_binddn,"enter");
          }
      } else
      {
        # Error ...
      }

      # If the user already is entering some passwords, also ask him the
      # password for the dhcp user
      my $openldap_dhcp_binddn = $cfg->val("General","dhcp_binddn");

      # Again no input from the user: 
      $dhcp_unencrypted_password = chars(8,8);
      $dhcp_password = `/usr/sbin/slappasswd -s '$dhcp_unencrypted_password'`;
      chomp( $dhcp_password );

      unless ( defined($dhcp_password) && $dhcp_password ne "" )
      {
          # Ask the user for the pdhcpd password
          if ( $modus eq "primary_master" )
          {
            ($dhcp_password,$dhcp_unencrypted_password) = askForOpenLDAPPassword($openldap_dhcp_binddn,"define");
          } else
          {
            ($dhcp_password,$dhcp_unencrypted_password) = askForOpenLDAPPassword($openldap_dhcp_binddn,"enter");
          }
      } else
      {
        # Error ...
      }

  } # End of if ( ( $local_modus eq "primary-master" ) || ( $local_modus eq "vm-node" ) )

  ##############################################################################
  ### Working on the file /etc/conf.d/slapd if needed by $modus
  ##############################################################################

  # Configuring /etc/conf.d/slapd
  print "\n";
  print "Working on $file_slapd ...\n";

  # Test if the file exists and is readable
  unless ( -r $file_slapd )
  {
      returnError(ERROR_MISSING_FILE_CODE,
                  ERROR_MISSING_FILE_STRING,
                  "Could not open $file_slapd for reading");
  }


  # Replacing OPTS=" -h 'ldap://127.0.0.1'" with OPTS=" -h 'ldap://$localIntIP'"
  open(FILE,$file_slapd);
  @output = <FILE>;
  close FILE;

  my $ldap_protocol;
  if ( $modus eq "demo-system" )
  {
    # LDAP
    $ldap_protocol = "ldap";
  } else
  {
    # LDAPS
    $ldap_protocol = "ldaps";
  }

  foreach $line (@output) {
    if ($line =~ "^OPTS=") {
      print  "Found:          $line";
#      $line =~ s/OPTS=.*/OPTS=\" -h 'ldap:\/\/$localIntIP ldap:\/\/$int_vip'\"/g;
#      print "Replacing with: OPTS=\" -h 'ldap:\/\/$localIntIP ldap:\/\/$int_vip'\"\n";
      $line =~ s/OPTS=.*/OPTS=\" -h '$ldap_protocol\:\/\/0.0.0.0'\"/g;
      print "Replacing with: OPTS=\" -h '$ldap_protocol\:\/\/0.0.0.0'\"\n";
      $error = 0;
    } # End of if ($line =~ "listen_addr")
  } # End of foreach $line (@output)

  if (!$dryrun) {
    print "Writing:        OPTS=\" -h '$ldap_protocol$localIntIP $ldap_protocol$int_vip'\"\n";
    print "To the file:    $file_slapd\n";
    open(FOUT,">$file_slapd") || die("Could not open $file_slapd for writing.");
    foreach $line (@output) {
      print FOUT $line;
    } # End of foreach $line (@output)
    close FOUT;
  } else {
    if ($debug) {
      foreach $line (@output) {
        print $line;
      } # End of foreach $line (@output)
    } # End of if ($debug)
    print "--dry-run: Would write 'OPTS=\" -h '$ldap_protocol$localIntIP $ldap_protocol/$int_vip'\"' to the file $file_slapd!\n";
  } # End of if (!$dryrun)

  # Setting the proper permisions on the acl directory and files ...
  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0750,$directory_acl);
  setMultipleFilePermissions($uid_root,$gid_ldap,0640,$directory_acl);

  # Setting the proper permisions on the data directory and files ...
  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0750,$directory_data);
  setMultipleFilePermissions($uid_root,$gid_ldap,0640,$directory_data);

  # Setting the proper permisions on the schema directory and files ...
  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0750,$directory_schema);
  setMultipleFilePermissions($uid_root,$gid_ldap,0640,$directory_schema);

  # Setting the proper permisions on the ssl directory ...
  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0755,$directory_ssl);

  # Create the neccessary directory structure to hold the OpenLDAP data
  print "\n";
  createDirectoryStructure($uid_ldap,$gid_ldap,0700,$directory_hdb_data);

  # Start the slapd daemon
  startDaemon("slapd",5);

  # Add the slapd daemon to the default runlevel
  rcUpdate("slapd","default");

  # Now we can start adding the data to the OpenLDAP directory with ldapadd
  print "\n";

  # We just want to add the node if we are the secondary master, the syncrepl
  # will take care of the rest
  if ( $local_modus eq "secondary-master" )
  {
      ### Working on 16_secondary-master-node
      #

      @sar_commands = (## general ##
                       {search => "<FOSS-CLOUD-NODE-NAME>",replace => $localNetworkHash->{"Node Name"}},

                       ## admin segment hashes ##
                       {search => "<FOSS-CLOUD-ADMIN-NETWORK-ADDRESS>",replace => $localNetworkHash->{"admin"}->{"ip"}},

                       ## int segment hashes ##
                       {search => "<FOSS-CLOUD-INT-NETWORK-ADDRESS>",replace => $localNetworkHash->{"int"}->{"ip"}},

                       ## data segment hashes##
                       {search => "<FOSS-CLOUD-DATA-NETWORK-ADDRESS>",replace => $localNetworkHash->{"data"}->{"ip"}},

                       ## pub segment hashes ##
                       {search => "<FOSS-CLOUD-PUB-NETWORK-ADDRESS>",replace => $localNetworkHash->{"pub"}->{"ip"}},
                       {search => "<FOSS-CLOUD-PUB-DOMAIN>",replace => $localNetworkHash->{"pub"}->{"domain"}},

                       # Path
                       {search  => "16_secondary-master-node.template",
                        replace => "16_secondary-master-node.ldif"
                       },
                      );


      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_16_secondary_master_node_template,
                        $file_16_secondary_master_node,
                        @sar_commands
                       );

      # Load the created ldif into the LDAP
      my $ldap_vip_server = $cfg->val("General","ldap_vip_name").".".$localNetworkHash->{'pub'}->{'domain'};
      loadOpenLDAPsingleLDIF($ldap_vip_server,$unencrypted_password,$file_16_secondary_master_node);

      # Create the cronjob for the backup

      # Get the values from the configuration file
      my $cronjob_string = $cfg->val("Cron","LDAPBackupString");
      my $cronjob_location = $cfg->val("Cron","LDAPBackupLocation");
      my $cronjob_file = $cfg->val("Cron","LDAPBackupFile");

      # Check whether the directory exists, if not create it
      unless ( -d $cronjob_location )
      {
          system("mkdir -p $cronjob_location");
          system("chmod 755 $cronjob_location");
      }


      # Open the file and write the cronjob if possible
      unless ( open(CRON,">$cronjob_location/$cronjob_file") )
      {
          # If the file could not be opened, tell the user so
          print "Could not open cronjob file ($cronjob_location/$cronjob_file) for";
          print "writing, please create the LDAP backup crobjob yourself!\n";
          sleep 5;
      } else
      {
          # Write the string to the file and close the file
          print CRON "# MIN HOUR DAY MONTH DAYOFWEEK\n";
          print CRON "# * * * * *\n";
          print CRON "# Cronjob for the LDAP backup\n";
          print CRON $cronjob_string."\n";
          close CRON;

          # Set the correct permission to the file
          system("chmod 644 $cronjob_location/$cronjob_file");

          print "Cronjob for LDAP Backup created!\n";
      }

      # Check it the .keep_net-nds_openldap-0 file already exists or not
      unless ( -e "$directory_hdb_data/.keep_net-nds_openldap-0" )
      {
          # If not write the .keep_net-nds_openldap-0 file and set proper permission
          system("touch $directory_hdb_data/.keep_net-nds_openldap-0");
          setSingleFilePermissions("file",$uid_root,$gid_root,0644,"$directory_hdb_data/.keep_net-nds_openldap-0");
      }

      # Check if the version-tag file already exists
      unless ( -e "$directory_hdb_data/.version-tag" )
      {
          # If not write the version tag file
          open(VERSION,">$directory_hdb_data/.version-tag") || die ("Cannot open $directory_hdb_data/.version-tag for writing");
          print VERSION "OLDPF='openldap-2.4.30'\n".
                        "# do NOT delete this. it is used\n".
                        "# to track versions for upgrading.";
          close VERSION;

          # Set correct permission 
          setSingleFilePermissions("file",$uid_root,$gid_root,0644,"$directory_hdb_data/.version-tag");
      }

      return $unencrypted_password;
  }

  ##############################################################################
  ### Worked on files needed by $modus
  ##############################################################################

  # Test if all files are readable
  unless ( -r $file_00_directory ||
           -r $file_01_administration_nextfreeuid ||
           -r $file_02_group_mapping_administration ||
           -r $file_03_reseller ||
           -r $file_04_customers ||
           -r $file_06_groups ||
           -r $file_06_services_virtualization
         )
  {
      returnError(ERROR_MISSING_FILE_CODE,ERROR_MISSING_FILE_STRING, "At least one of the LDIF files is not readable.");
  }


  header("Adding data ...");
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_00_directory);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_01_administration_nextfreeuid);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_02_group_mapping_administration);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_23_roles);

  ##############################################################################
  # Working on /etc/openldap/data/02_services-administration.ldif
  # if needed by $modus
  ##############################################################################

  if ( ( $local_modus eq "primary-master" ) || ( $local_modus eq "vm-node" ) )
  {

      # Configuring /etc/openldap/data/02_services-administration.ldif
      print "\n";
      print "Working on $file_02_administration_services ...\n";

      # Replace:
      # labeledURI: <FOSS-CLOUD-LABELED-URI>
      # With:
      # labeledURI: ldap://192.0.2.87:389

      # Replace:
      # sstLDAPBindPassword: <FOSS-CLOUD-MANAGER-PASSWORD>
      # With:
      # sstLDAPBindPassword: admin

      # Create the crypted syncreply password
      my $crypted_syncrepl_password = `/usr/sbin/slappasswd -s '$syncrepl_password'`;
      chomp($crypted_syncrepl_password);

      # Create the search_and_replace commands to replace the LDIF template with
      # the correct values
      @sar_commands = ( {search => "<FOSS-CLOUD-PROV-BACKUP-KVM-PASSWORD>", replace => $prov_backup_kvm_password},
                        {search => "<FOSS-CLOUD-DHCP-PASSWORD>", replace => $dhcp_password},
                        {search => "<FOSS-CLOUD-SYNCREPL-PASSWORD>", replace => $crypted_syncrepl_password},
                      );

      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_02_administration_services_template,
                        $file_02_administration_services,
                        @sar_commands
                       );

      print "\n";

      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_02_administration_services);

  } # End of if ( ( $local_modus eq "primary-master" ) || ( $local_modus eq "vm-node" ) )
  # Worked on /etc/openldap/data/02_services-administration.ldif

  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_03_reseller);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_04_customers);

  ##############################################################################
  # Working on /etc/openldap/data/05_people.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {

    # Variables we need
    my $givenname;
    my $surname;
    my $gender = "";
    my $mail = "";
    my $timezone = "";
    my $password;
    $language = "EN";


    # Gives the user the possibility to reenter all information
    my $correct = 0;

    # We don't want user input in the demo system
    if ( $modus eq "demo-system" )
    {
        $givenname = "FOSS-Cloud";
        $surname = "Administrator";
        $gender = "n";
        $mail = 'info@foss-cloud.org';
        $timezone = "UTC+01";
        $language = "EN";
        $password = `/usr/sbin/slappasswd -s admin`;
        chomp($password);
        $correct = 1; 
    }

    while ( ! $correct )
    {
        # Ask for all necessary information
        print "\n";
        print "Please enter the the information for the FOSS-Cloud ";
        print "administrator with which\nyou will log in on the webinterface ";
        print "(username is 'admin'):";
        print "\n\n";
        print "Given name: ";
        chomp( $givenname = <STDIN> );

        print "\n";
        print "Surname: ";
        chomp( $surname = <STDIN> );

        # Local gender validation
        while ( $gender !~ m/^[fmn]$/ )
        {
            print "\n";
            print "Gender [f(emale)/m(ale)/n(eutral)]: ";
            chomp( $gender = <STDIN> );
        }

        # Local mail address validation
        while ( $mail !~ m/^.+\@.+\..{2,3}$/ )
        {
            print "\n";
            print "Mail address: ";
            chomp( $mail = <STDIN> );
        }

        # Local language validation
        # while ( $language !~ m/^\w{2}\-\w{2}$/ )
        # {
        #     print "\n";
        #     print "Language, in the form of 'en-GB' (default: en-GB): ";
        #     chomp( $language = <STDIN> );

            # Assign default if nothing was entered
        #     $language = "en-GB" unless ( $language );

        # }

        # Get the systems timezone in the form +0100
        $timezone = strftime "%z",localtime();

        if ( $timezone =~ m/^([+-]\d{2})(\d{2})/ )
        {
            # Test if the second part is 00 if yes just take the UTC+first part
            if ( $2 eq "00" )
            {
                $timezone = "UTC$1";
            } else
            {
                $timezone = "UTC$1:$2";
            }
        } else
        {
            # Timezone does not match expected format, ask the user to enter 
            # it
            # Local timezone validation
            while ( $timezone !~ m/^UTC[+-]\d{2}$/ )
            {
                print "\n";
                print "Timezone offset, in the form of 'UTC+01' (default: UTC+01) : ";
                chomp( $timezone = <STDIN> );

                # Assign default if nothing was entered
                $timezone = "UTC+01" unless ( $timezone );

            }
        }

        # Newline as always
        print "\n";

        # Ask for the password: 
        ($password, my $uncrypted) = askForOpenLDAPPassword("admin","define");

        # Show the user what he entered: 
        print "\nIs the follwing information correct?:\n";
        print "\nGivenname:   $givenname\n";
        print "Surname:     $surname\n";
        print "Gender:      $gender\n";
        print "Language:    $language\n";
        print "Mailaddress: $mail\n";
        print "Timezone:    $timezone\n";
        print "Password:    $password\n\n";

        my $user_correct = "";

        while ( $user_correct !~ m/^[yn]$/i )
        {
            print "\nIs everything correct? [Y/n]: ";

            chomp( $user_correct = <STDIN> );

            # Check if the user entered something, if not take default
            $user_correct = "y" unless ( $user_correct );
        }
        
        # If everything is correct we can quit the while loop and continue
        if ( $user_correct =~ m/^y$/i )
        {
            $correct = 1;
        } else
        {
            # Otherwise we need to reset all information
            $gender = "";
            $mail = "";
            $timezone = "";
        }

    }

    # Now lets replace the information in the template and create a ldif
    @sar_commands = ( {search => "<FOSS-CLOUD-PEOPLE-GENDER>", replace => $gender },
                      {search => "<FOSS-CLOUD-PEOPLE-GIVENNAME>", replace => $givenname},
                      {search => "<FOSS-CLOUD-PEOPLE-SURNAME>", replace => $surname},
                      {search => "<FOSS-CLOUD-PEOPLE-LANGUAGE>", replace => $language},
                      {search => "<FOSS-CLOUD-PEOPLE-PASSWORD>", replace => $password},
                      {search => "<FOSS-CLOUD-PEOPLE-MAIL>", replace => $mail},
                      {search => "<FOSS-CLOUD-PEOPLE-TIMEZONE>", replace => $timezone},
                    );

    searchAndReplace( $file_05_people_template,
                      $file_05_people,
                      @sar_commands
                     );    


  }

  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_05_people);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_06_groups);
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_06_services_virtualization);


  ##############################################################################
  # Working on /etc/openldap/data/07_services_virtualization_authentication.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {

      # Configuring /etc/openldap/data/07_services_virtualization_authentication.ldif
      print "\n";
      print "Working on $file_07_authentication_services_virtualization ...\n";

      # Replace:
      # labeledURI: <FOSS-CLOUD-LABELED-URI>
      # With:
      # labeledURI: ldap://192.0.2.87:389

      # Replace:
      # sstLDAPBindPassword: <FOSS-CLOUD-MANAGER-PASSWORD>
      # With:
      # sstLDAPBindPassword: admin

      # Create the search_and_replace commands to replace the LDIF template with
      # the correct values
      @sar_commands = ( {search => "<FOSS-CLOUD-LABELED-URI>", replace => "ldap://$localIntIP:389"},
                           {search => "<FOSS-CLOUD-MANAGER-PASSWORD>", replace => $unencrypted_password},
                      );

      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_07_authentication_services_virtualization_template,
                        $file_07_authentication_services_virtualization,
                        @sar_commands
                       );

      print "\n";

      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_07_authentication_services_virtualization);

  } # End of if ( $local_modus eq "primary-master" )
  # Worked on /etc/openldap/data/07_services_virtualization_authentication.ldif


  ##############################################################################
  # Working on /etc/openldap/data/08_configuration_services_virtualization.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {
      # Configuring /etc/openldap/data/08_configuration_services_virtualization.ldif
      print "\n";
      print "Working on $file_08_configuration_services_virtualization ...\n";

      # get the DNS Hosts form /etc/resolv.conf
      open(DNS,$dns_conf_file) || die("Could not open $dns_conf_file for reading.");

      @output = <DNS>;
      
      foreach $line (@output){
        if($line =~ m/^nameserver\s+/){
              $'=~m/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/;
          push(@dns_hosts,$&);
        }
      }

      # Generate the string to wirte in the ldif
      foreach my $dns_host (@dns_hosts){
        $dns_host_string.="\nsstNetworkDNSHost: $dns_host";
      }

      # get the NTP information form /etc/ntp.conf
      open(NTP,$ntp_conf_file) || die("Could not open $ntp_conf_file for reading.");

      @output = <NTP>;
      my $match;

      foreach $line (@output){
        if($line =~ m/^server\s+/){
          $match=$';
          # Get everything before the next space/tab
          $match=~m/\s+/;
          $match = $`;
          push(@ntp_hosts,$match);
        }
      }

      # Generate the string to wirte in the ldif
      foreach my $ntp_host (@ntp_hosts){
        $ntp_host_string.="\nsstNetworkNTPHost: $ntp_host";
      }

      # Generate the search and replace commands for each segement.
      @sar_commands = (## admin segment hashes ##
                          {search => "<FOSS-CLOUD-ADMIN-VLAN-ID>",replace => $localNetworkHash->{"admin"}->{"id"}},
                          {search => "<FOSS-CLOUD-ADMIN-NETWORK-ADDRESS>",replace => $localNetworkHash->{"admin"}->{"ip"}},
                          {search => "<FOSS-CLOUD-ADMIN-NETMASK>",replace => $localNetworkHash->{"admin"}->{"netmask"}},
                          {search => "<FOSS-CLOUD-ADMIN-BROADCAST>",replace => $localNetworkHash->{"admin"}->{"broadcast"}},
                          {search => "<FOSS-CLOUD-ADMIN-DOMAIN>",replace => $localNetworkHash->{"admin"}->{"domain"}},

                          ## int segment hashes ##
                          {search => "<FOSS-CLOUD-INT-VLAN-ID>",replace => $localNetworkHash->{"int"}->{"id"}},
                          {search => "<FOSS-CLOUD-INT-NETWORK-ADDRESS>",replace => $localNetworkHash->{"int"}->{"ip"}},
                          {search => "<FOSS-CLOUD-INT-NETMASK>",replace => $localNetworkHash->{"int"}->{"netmask"}},
                          {search => "<FOSS-CLOUD-INT-BROADCAST>",replace => $localNetworkHash->{"int"}->{"broadcast"}},
                          {search => "<FOSS-CLOUD-INT-DOMAIN>",replace => $localNetworkHash->{"int"}->{"domain"}},

                          ## data segment hashes##
                          {search => "<FOSS-CLOUD-DATA-VLAN-ID>",replace => $localNetworkHash->{"data"}->{"id"}},
                          {search => "<FOSS-CLOUD-DATA-NETWORK-ADDRESS>",replace => $localNetworkHash->{"data"}->{"ip"}},
                          {search => "<FOSS-CLOUD-DATA-NETMASK>",replace => $localNetworkHash->{"data"}->{"netmask"}},
                          {search => "<FOSS-CLOUD-DATA-BROADCAST>",replace => $localNetworkHash->{"data"}->{"broadcast"}},
                          {search => "<FOSS-CLOUD-DATA-DOMAIN>",replace => $localNetworkHash->{"data"}->{"domain"}},

                          ## pub segment hashes ##
                          {search => "<FOSS-CLOUD-PUB-VLAN-ID>",replace => $localNetworkHash->{"pub"}->{"id"}},
                          {search => "<FOSS-CLOUD-PUB-NETWORK-ADDRESS>",replace => $localNetworkHash->{"pub"}->{"ip"}},
                          {search => "<FOSS-CLOUD-PUB-NETMASK>",replace => $localNetworkHash->{"pub"}->{"netmask"}},
                          {search => "<FOSS-CLOUD-PUB-DEFAULT-GATEWAY>",replace => $localNetworkHash->{"pub"}->{"gateway"}},
                          {search => "<FOSS-CLOUD-PUB-BROADCAST>",replace => $localNetworkHash->{"pub"}->{"broadcast"}},
                          {search => "<FOSS-CLOUD-PUB-DOMAIN>",replace => $localNetworkHash->{"pub"}->{"domain"}},
                          {search => "<FOSS-CLOUD-NTP-INFO>",replace => $ntp_host_string},
                          {search => "<FOSS-CLOUD-DNS-INFO>",replace => $dns_host_string},

                          # General
                          {search => "<FOSS-CLOUD-ID>" , replace => $foss_cloud_uuid },

                          # Path
                          {search  => "08_configuration_services_virtualization.template",
                           replace => "08_configuration_services_virtualization.ldif"
                          },
                         );


      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_08_configuration_services_virtualization_template,
                        $file_08_configuration_services_virtualization,
                        @sar_commands
                       );

      # Load the created ldif into the LDAP
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_08_configuration_services_virtualization);


  } # End of ( $local_modus eq "primary-master" )
  # Worked on /etc/openldap/data/08_configuration_services_virtualization.ldif

  ##############################################################################
  # Working on /etc/openldap/data/09_networks_services_virtualization.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {
      ### Working on 09_networks_services_virtualization
      #
      
      # Define some vars for the search and replace hash later
      my $network_address;
      my $netmask;
      my $domain;
      my $dns;
      my $gateway;
      my $broadcast;
      my $ntp;

      # Here we need to differ the global $modus, demo-system != primary-master
      if ( $modus eq "primary-master" || $modus eq "single-server")
      {
          # Again create the NTP information for writing to the LDIF. We have already
          # collected the host as we were working on 08_configuration_services_
          # virtualization, so take this array and add the appropriate LDIF attributes



          # Same thing for the DNS server, we already have the servers in an array so
          # just add the LDIF appropriate attributes

          # Generate the string to wirte in the ldif
          $dns_host_string = join(",",@dns_hosts);

          # Calculate the network address form the public IP and netmask
          $network_address = NetAddr::IP::Lite->new($localNetworkHash->{"pub"}->{"ip"}."/".$localNetworkHash->{"pub"}->{"netmask"});
          $network_address = $network_address->network()->addr();

          # set the vars appropriate the the network hash
          $netmask = $localNetworkHash->{"pub"}->{"netmask"};
          $domain = $localNetworkHash->{"pub"}->{"domain"};
          $dns = $dns_host_string;
          $gateway = $localNetworkHash->{"pub"}->{"gateway"};
          $broadcast = $localNetworkHash->{"pub"}->{"broadcast"};
          
      } elsif ( $modus eq "demo-system" )
      {
          # Get the information from the configuration file;
          $network_address = $cfg->val($modus,"dhcp_network");
          $netmask = $cfg->val($modus,"dhcp_netmask");
          $domain =$cfg->val($modus,"dhcp_domain");
          $dns = $cfg->val($modus,"dhcp_DNS");
          $gateway = $cfg->val($modus,"dhcp_default_gateway");
          $broadcast = $cfg->val($modus,"dhcp_broadcast");
          

      }
      
      # Generate the string to wirte in the ldif
      $ntp_host_string = join(",",@ntp_hosts);

      $ntp = $ntp_host_string;

      @sar_commands = ( {search => "<FOSS-CLOUD-PUB-SUBNET-ADDRESS>", replace => $network_address},
                        {search => "<FOSS-CLOUD-PUB-NETMASK>", replace => $netmask},
                        {search => "<FOSS-CLOUD-PUB-DOMAIN>", replace => $domain},
                        {search => "<FOSS-CLOUD-DNS-INFO>", replace => $dns},
                        {search => "<FOSS-CLOUD-PUB-DEFAULT-GATEWAY>", replace => $gateway},
                        {search => "<FOSS-CLOUD-PUB-BROADCAST>", replace => $broadcast},
                        {search => "<FOSS-CLOUD-NTP-INFO>", replace => $ntp},
                      );

      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_09_networks_services_virtualization_template,
                        $file_09_networks_services_virtualization,
                        @sar_commands
                       );

      # Load the created ldif into the ldap
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_09_networks_services_virtualization);

  }# End of if ( $local_modus eq "primary-master" )
  # Working on /etc/openldap/data/09_networks_services_virtualization.ldif



  # Load the ldifs into the LDAP to be able to continue
  if ( -r $file_10_nodes_services_virtualization &&
       -r $file_11_storage_services_virtualization &&
       -r $file_12_vm_profiles_services_virtualization
     )
  {
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_10_nodes_services_virtualization);
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_11_storage_services_virtualization);
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_12_vm_profiles_services_virtualization);
      
  } else
  {
      returnError(ERROR_MISSING_FILE_CODE,ERROR_MISSING_FILE_STRING, "One of the files $file_10_nodes_services_virtualization, $file_11_storage_services_virtualization or $file_12_vm_profiles_services_virtualization is not readable.");
  }


  ##############################################################################
  # Working on /etc/openldap/data/14_vm-pools_services_virtualization.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {

      ### Working on 14_vm-pools_services_virtualization
      #

      @sar_commands = (## general ##
                       {search => "<FOSS-CLOUD-NODE-NAME>",replace => $localNetworkHash->{"Node Name"}},

                       ## pub segment hashes ##
                       {search => "<FOSS-CLOUD-PUB-DOMAIN>",replace => $localNetworkHash->{"pub"}->{"domain"}},

                       # Path
                       {search  => "14_vm-pools_services_virtualization.template",
                        replace => "14_vm-pools_services_virtualization.ldif"
                       },
                      );

      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_14_vm_pools_services_virtualization_template,
                        $file_14_vm_pools_services_virtualization,
                        @sar_commands
                       );

      # Load the created ldif into the LDAP
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_14_vm_pools_services_virtualization);


  } # End of if ( $local_modus eq "primary-master" )
  # Worked on /etc/openldap/data/14_vm-pools_services_virtualization.ldif



  # Load the ldif into the LDAP to be able to continue
  if ( -r $file_15_vms_services_virtualization )
  {
    loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_15_vms_services_virtualization);
  } else
  {
      returnError(ERROR_MISSING_FILE_CODE,ERROR_MISSING_FILE_STRING,
                 "$file_15_vms_services_virtualization does not exist or has"
                 ." incorrect permissions");
  }


  ##############################################################################
  # Working on /etc/openldap/data/16_primary-master-node.ldif
  # if needed by $modus
  ##############################################################################

  if ( $local_modus eq "primary-master" )
  {

      ### Working on 16_primary-master-node
      #

      @sar_commands = (## general ##
                       {search => "<FOSS-CLOUD-NODE-NAME>",replace => $localNetworkHash->{"Node Name"}},

                       ## admin segment hashes ##
                       {search => "<FOSS-CLOUD-ADMIN-NETWORK-ADDRESS>",replace => $localNetworkHash->{"admin"}->{"ip"}},

                       ## int segment hashes ##
                       {search => "<FOSS-CLOUD-INT-NETWORK-ADDRESS>",replace => $localNetworkHash->{"int"}->{"ip"}},

                       ## data segment hashes##
                       {search => "<FOSS-CLOUD-DATA-NETWORK-ADDRESS>",replace => $localNetworkHash->{"data"}->{"ip"}},

                       ## pub segment hashes ##
                       {search => "<FOSS-CLOUD-PUB-NETWORK-ADDRESS>",replace => $localNetworkHash->{"pub"}->{"ip"}},
                       {search => "<FOSS-CLOUD-PUB-DOMAIN>",replace => $localNetworkHash->{"pub"}->{"domain"}},

                       # Path
                       {search  => "16_primary-master-node.template",
                        replace => "16_primary-master-node.ldif"
                       },
                      );


      # Replace the template with the correct values which are specified in the
      # @sar_commands array
      searchAndReplace( $file_16_primary_master_node_template,
                        $file_16_primary_master_node,
                        @sar_commands
                       );

      # Load the created ldif into the LDAP
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_16_primary_master_node);


  } # End of if ( $local_modus eq "primary-master" )
  # Worked on /etc/openldap/data/16_primary-master-node.ldif


  ##############################################################################
  # Working on /etc/openldap/data/17_ranges_networks_services_virtualization.ldif
  # if needed by $modus
  ##############################################################################

  if ( $modus eq "demo-system" )
  {
      # Load the ranges into the LDAP
      loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_17_ranges_networks_services_virtualization);
  }
  # Worked on 17_ranges_networks_services_virtualization

  # And finally load the monitoring services into the ldap
  loadOpenLDAPsingleLDIF($ldap_server,$unencrypted_password,$file_18_services_monitoring);

  print "\n";


  # Create the cronjob for the backup

  # Get the values from the configuration file
  my $cronjob_string = $cfg->val("Cron","LDAPBackupString");
  my $cronjob_location = $cfg->val("Cron","LDAPBackupLocation");
  my $cronjob_file = $cfg->val("Cron","LDAPBackupFile");

  # Check whether the directory exists, if not create it
  unless ( -d $cronjob_location )
  {
      system("mkdir -p $cronjob_location");
      system("chmod 755 $cronjob_location");
  }


  # Open the file and write the cronjob if possible
  unless ( open(CRON,">$cronjob_location/$cronjob_file") )
  {
      # If the file could not be opened, tell the user so
      print "Could not open cronjob file ($cronjob_location/$cronjob_file) for";
      print "writing, please create the LDAP backup crobjob yourself!\n";
      sleep 5;
  } else
  {
      # Write the string to the file and close the file
      print CRON "# MIN HOUR DAY MONTH DAYOFWEEK\n";
      print CRON "# * * * * *\n";
      print CRON "# Cronjob for the LDAP backup\n";
      print CRON $cronjob_string."\n";
      close CRON;

      # Set the correct permission to the file
      system("chmod 644 $cronjob_location/$cronjob_file");
      
      print "Cronjob for LDAP Backup created!\n";
  }

  # Check it the .keep_net-nds_openldap-0 file already exists or not
  unless ( -e "$directory_hdb_data/.keep_net-nds_openldap-0" )
  {
      # If not write the .keep_net-nds_openldap-0 file and set proper permission
      system("touch $directory_hdb_data/.keep_net-nds_openldap-0");
      setSingleFilePermissions("file",$uid_root,$gid_root,0644,"$directory_hdb_data/.keep_net-nds_openldap-0");
  }

  # Check if the version-tag file already exists
  unless ( -e "$directory_hdb_data/.version-tag" )
  {
      # If not write the version tag file
      open(VERSION,">$directory_hdb_data/.version-tag") || die ("Cannot open $directory_hdb_data/.version-tag for writing");
      print VERSION "OLDPF='openldap-2.4.30'\n".
                    "# do NOT delete this. it is used\n".
                    "# to track versions for upgrading.";
      close VERSION;

      # Set correct permission 
      setSingleFilePermissions("file",$uid_root,$gid_root,0644,"$directory_hdb_data/.version-tag");
  }

  print "\n";

  return $unencrypted_password;

} # End of sub configureOpenLDAP


######################################################################################################
# configureDHCP
######################################################################################################
# Description:
#   Replaces the placeholder in the dhcp.conf file with the correct value
# Usage:
#   configureDHCP($localNetworkHash);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub configureDHCP {

    my $localNetworkHash = shift;

    my $file_dhcp_conf_template = $cfg->val($modus,"file_dhcp_conf_template");
    my $file_dhcp_conf = $cfg->val($modus,"file_dhcp_conf");
    my $ldap_port = $cfg->val("openLDAP","port");
    $ldap_port = "389" if ( $modus eq "demo-system" );

    # Configuring the DHCP Daemon
    header("Configuring the DHCP Daemon ...");
    
    # Working on the file /var/www/localhost/htdocs/vm-manager/vm_config.php ...
    print "\n";
    print "Working on $file_dhcp_conf ...\n";

    # If the port is 636 then we need to add some more attributes to the config
    # file
    if ( $ldap_port eq "636" )
    {
        $ldap_port = "636;\n";
        $ldap_port .= "ldap-ssl ldaps;\n";
        $ldap_port .= "ldap-tls-ca-file \"/etc/ssl/certs/FOSS-Cloud_CA.cert.pem\"";
    }

    # Generate the search and replace commands to replace the placeholders in
    # template
    my $ldap_uri = "ldapm.".$localNetworkHash->{"pub"}->{"domain"};
    $ldap_uri = "127.0.0.1" if ( $modus eq "demo-system" );
    my @sar_commands = ( { search => "<FOSS-CLOUD-LDAP-SERVER>", replace =>  $ldap_uri },
                         { search => "<FOSS-CLOUD-DHCP-PASSWORD>", replace => $dhcp_unencrypted_password}, 
                         { search => "<FOSS-CLOUD-LDAP-PORT>", replace => $ldap_port});

    searchAndReplace( $file_dhcp_conf_template,
                      $file_dhcp_conf,
                      @sar_commands
                    );

}

######################################################################################################
# configureVMManager
######################################################################################################
# Description: 
#   Configures the VM-Manager with the OpenLDAP Server IP and the Manager password.
# Usage:
#   configureVMManager($localNetworkHash,$unencrypted_password);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub configureVMManager {
  my ($localNetworkHash,$unencrypted_password) = @_;
  my $file_vmmanager_conf = $cfg->val($modus,"file_vmmanager_conf");
  my $error = 1;
  my @output;
  my $line;

  # OpenLDAP runs on the int VLAN
  my $localIntIP = $localNetworkHash->{"int"}->{"vip"};

  # Configuring the VM-Manager
  header("Configuring the VM-Manager daemon ...");

  # Working on the file /var/www/localhost/htdocs/vm-manager/vm_config.php ...
  print "\n";
  print "Working on $file_vmmanager_conf ...\n";

  # Replace:
  # 'server' => 'ldaps://<FOSS-CLOUD-LDAP-HOSTNAME>/',
  # or
  # 'server' => 'ldap://192.0.2.5/',
  # With:
  # 'server' => 'ldap://192.0.2.5/',

  # Replace:
  # 'port' => 636,
  # Or:
  # 'port' => 389,
  # With:
  # 'port' => 389,

  # Replace:
  # 'bind_pwd' => '<FOSS-CLOUD-LDAP-PASSWORD>',
  # Or:
  # 'bind_pwd' => 'admin',
  # With:
  # 'bind_pwd' => 'admin',
  open(FILE,$file_vmmanager_conf) || die("Could not open $file_vmmanager_conf for reading.");
  @output = <FILE>;
  close FILE;

  my $ldap_uri;
  my $ldap_port;
  if ( $modus eq "demo-system" )
  {
    # LDAP
    $ldap_uri = "ldap://".$localIntIP;
    $ldap_port = "389";
  } else
  {
    # LDAPS
    $ldap_uri = "ldaps://ldapm.".$localNetworkHash->{'pub'}->{'domain'};
    $ldap_port = "636";
  }

  foreach $line (@output) {
    if ($line =~ "'server'") {
      print "Found:          $line";
      $line =~ s/'server'.*/'server' => '$ldap_uri\/',/g; #'
      print "Replacing with:                         'server' => '$ldap_uri/',\n";
      $error = 0;
    } # End of if ($line =~ "'server'")
    if ($line =~ "'port'") {
      print "Found:          $line";
      $line =~ s/'port'.*/'port' => $ldap_port,/g;
      print "Replacing with:                         'port' => $ldap_port,\n";
      $error = 0;
    } # End of if ($line =~ "'port'")
    if ($line =~ "'bind_pwd'") {
      print "Found:          $line";
      $line =~ s/'bind_pwd'.*/'bind_pwd' => '$unencrypted_password',/g;
      print "Replacing with:                         'bind_pwd' => '$unencrypted_password',\n";
      $error = 0;
    } # End of if ($line =~ "'bind_pwd'")
  } # End of foreach $line (@output)

  if (!$dryrun) {
    print "Writing:        'server' => '$ldap_uri/',\n";
    print "Writing:        'port' => $ldap_port,\n";
    print "Writing:        'bind_pwd' => '$unencrypted_password',\n";
    print "To the file:    $file_vmmanager_conf\n";
    open(FOUT,">$file_vmmanager_conf") || die("Could not open $file_vmmanager_conf for writing.");
    foreach $line (@output) {
      print FOUT $line;
    } # End of foreach $line (@output)
    close FOUT;
  } else {
    if ($debug) {
      foreach $line (@output) {
        print $line;
      } # End of foreach $line (@output)
    } # End of if ($debug)
    print "--dry-run: Would write ''server' => '$ldap_uri/,' to the file $file_vmmanager_conf!\n";
    print "--dry-run: Would write ''port' => $ldap_port,' to the file $file_vmmanager_conf!\n";
    print "--dry-run: Would write ''bind_pwd' => '$unencrypted_password',' to the file $file_vmmanager_conf!\n";
  } # End of if (!$dryrun)

  print "\n";

} # End of sub configureVMManager


######################################################################################################
# configurePhpLDAPadmin
######################################################################################################
# Description: 
#   Configures phpLDAPadmin for the local OpenLDAP server.
# Usage:
#   configurePhpLDAPadmin($localNetworkHash);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub configurePhpLDAPadmin {
    
  my ($localNetworkHash)=@_;
  
  my $file_phpldapadmin_template = $cfg->val($modus,"file_phpldapadmin_template");
  my $file_phpldapadmin_conf = $cfg->val($modus,"file_phpldapadmin_conf");
  my $error = 1;
  my @output;
  my $line;

  my $ldap_protocol;
  my $ldap_port;
  if ( $modus eq "demo-system" )
  {
    # LDAP
    $ldap_protocol = "ldap://";
    $ldap_port = "389";
  } else
  {
    # LDAPS
    $ldap_protocol = "ldaps://";
    $ldap_port = "636";
  }

  # OpenLDAP runs on the int VLAN
  my $localIntIP = $localNetworkHash->{"int"}->{"ip"};
  my $localIntVIP = $localNetworkHash->{"int"}->{"vip"};
  my $remoteIntIP = $localNetworkHash->{"int"}->{"secondary_master_ip"};

  # Configuring the phpLDAPadmin
  header("Configuring phpLDAPadmin ...");


  # Setting the proper permisions on the openldap directory
#  print "\n";
#  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0755,$directory_openldap);

  # Working on the file /var/www/localhost/htdocs/phpldapadmin/config/config.php
  print "\n";
  print "Working on $file_phpldapadmin_template ...\n";

  # Replace:
  # $servers->setValue('server','host','ldaps://<FOSS-CLOUD-LDAP-VIP>');
  # With: 
  # $servers->setValue('server','host','ldap://192.0.2.87');

  # Generate the search-and-replace commands:
  # Take care of port and address ldap:// => 389 ldaps:// => 636
  my $ldap_vip_uri = "ldapm.".$localNetworkHash->{'pub'}->{'domain'};
  my $ldap_rip1_uri = "ldapm-01.".$localNetworkHash->{'pub'}->{'domain'};
  my $ldap_rip2_uri = "ldapm-02.".$localNetworkHash->{'pub'}->{'domain'};

  if ( $modus eq "demo-system" )
  {
    $ldap_vip_uri = $localIntIP;
    $ldap_rip1_uri = $localIntVIP;
    $ldap_rip2_uri = $remoteIntIP;
  }

  my @sar_commands = (
                      {search => "<FOSS-CLOUD-LDAP-VIP>",replace => $ldap_protocol.$ldap_vip_uri},
                      {search => "<FOSS-CLOUD-LDAP-RIP1>",replace => $ldap_protocol.$ldap_rip1_uri},
                      {search => "<FOSS-CLOUD-LDAP-RIP2>",replace => $ldap_protocol.$ldap_rip2_uri},
                      {search => "<FOSS-CLOUD-LDAP-PORT>",replace => $ldap_port},
                     );

  searchAndReplace ( $file_phpldapadmin_template,
                     $file_phpldapadmin_conf,
                     @sar_commands
                   );

  print "\n";

} # End of configurePhpLDAPadmin


######################################################################################################
# configureApache2
######################################################################################################
# Description: 
#   Configures and starts the Apache2 web server.
# Usage:
#   configureApache2($localNetworkHash);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub configureApache2 {

  my ($localNetworkHash)=@_;
  
  my $file_localhost_conf = $cfg->val($modus,"file_localhost_conf");
  my $error = 1;
  my @output;
  my $line;

  # Apache2 runs on the pub VLAN
  my $localPubIP = $localNetworkHash->{"pub"}->{"ip"};
  my $localPubDomain =  $localNetworkHash->{"pub"}->{"domain"};
  my $pub_vip = $localNetworkHash->{"pub"}->{"vip"};

  $pub_vip = $localNetworkHash->{"pub"}->{"ip"} if ( $modus eq "demo-system" || $modus eq "single-server");

  # Configuring the apache2 daemon
  print "\n";
  header("Configuring the apache2 daemon ...");

  # Make sure, that the web server daemon apache2 is not running
  stopDaemon("apache2");

  # Apache vip name for demo system
  $apache_vip_name = "foss-cloud.".$localPubDomain if ( $modus eq "demo-system" );

  while ( $apache_vip_name !~ m/.+\..+\..{2,3}/ )
  {
      # Ask for the apache2 VIP name
      print "\nPlease enter the apache VIP name (default: foss-cloud."
           .$localPubDomain."): ";
      chomp( $apache_vip_name = <STDIN> );

      # If no name is entered take default one
      $apache_vip_name = "foss-cloud.".$localPubDomain unless ( $apache_vip_name );

  }


  # Setting the proper permisions on the openldap directory
#  print "\n";
#  setSingleFilePermissions("directory",$uid_root,$gid_ldap,0755,$directory_openldap);

  # Working on the file /etc/apache2/vhosts.d/localhost.conf
  print "\n";
  print "Working on $file_localhost_conf ...\n";

  # Replace:
  # Listen *:80
  # Or:
  # Listen 192.0.2.5:80
  # With: 
  # Listen 192.0.2.5:80

  # Replace:
  # <VirtualHost *:80>
  # Or:
  # <VirtualHost 192.0.2.5:80>
  # With: 
  # <VirtualHost 192.0.2.5:80>
  open(FILE,$file_localhost_conf) || die("Could not open $file_localhost_conf for reading.");
  @output = <FILE>;
  close FILE;

  my $port;
  if ( $modus eq "demo-system" )
  {
    $port = "80";
  } else
  {
    $port = "443";
  }

  foreach $line (@output) {
    if ($line =~ "^Listen") {
      print "Found:          $line";
      $line =~ s/Listen.*/Listen $pub_vip:$port/g;
      print "Replacing with: Listen $localPubIP:$port\n";
      $error = 0;
    } # End of if ($line =~ "^Listen")
    if ($line =~ "^<VirtualHost") {
      print "Found:          $line";
      $line =~ s/<VirtualHost.*/<VirtualHost $pub_vip:$port>/g;
      print "Replacing with: <VirtualHost $localPubIP:$port>\n";
      $error = 0;
    } # End of if ($line =~ "^<VirtualHost")
    
    if ($line =~ m/^\s+SSLCertificateFile/) {
      print "Found:          $line";
      my $cert_file = $apache_vip_name.".cert.pem";
      $line =~ s/<FOSS-CLOUD-APACHE-CERTIFICATE-FILE>/$cert_file/g;
      print "Replacing with: $cert_file\n";
      $error = 0;
    } # End of if ($line =~ "^<VirtualHost")
    if ($line =~ m/^\s+SSLCertificateKeyFile/) {
      print "Found:          $line";
      my $cert_key_file = $apache_vip_name.".key.pem";
      $line =~ s/<FOSS-CLOUD-APACHE-CERTIFICATE-KEY-FILE>/$cert_key_file/g;
      print "Replacing with: $cert_key_file\n";
      $error = 0;
    } # End of if ($line =~ "^<VirtualHost")


    if ( $line =~ m/^\s+ServerName/ )
    {
        $line =~ s/ServerName.*/ServerName $apache_vip_name/;
        print "Replacing with:    ServerName ".$apache_vip_name."\n";
    }

  } # End of foreach $line (@output)

  if (!$dryrun) {
    print "Writing:        Listen $localPubIP:$port\n";
    print "Writing:        <VirtualHost $localPubIP:$port>\n";
    print "To the file:    $file_localhost_conf\n";
    open(FOUT,">/etc/apache2/vhosts.d/localhost.conf") || die("Could not open $file_localhost_conf for writing.");
    foreach $line (@output) {
      print FOUT $line;
    } # End of foreach $line (@output)
    close FOUT;
  } else {
    if ($debug) {
      foreach $line (@output) {
        print $line;
      } # End of foreach $line (@output)
    } # End of if ($debug)
    print "--dry-run: Would write 'Listen $pub_vip:80' to the file $file_localhost_conf!\n";
    print "--dry-run: Would write '<VirtualHost $pub_vip:80>' to the file $file_localhost_conf!\n";
  } # End of if (!$dryrun)

  # Start the apache2 daemon
#  startDaemon("apache2");

  # Add the apache2 daemon to the default runlevel
#  rcUpdate("apache2","default");

} # End of configureApache2


################################################################################
# configureUcarp
################################################################################
# Description:
#   Configures and starts ucarp
# Usage:
#   configureUcarp();
################################################################################
# Return Values:
#   none
################################################################################
sub configureUcarp
{
    
  #TODO: this method with search replace

  my $localNetworkHash = shift;
  # Configuring ucarp
  print "\n";
  header("Configuring ucarp ...");

  my @output;
  my $ucarp_password;

  # Check if the password is defined, if not generate a new one
  if ( $ucarp_pub_password eq "" )
  {
    $ucarp_password = chars(8,8);
  } else
  {
    $ucarp_password = $ucarp_pub_password;
  }

  # Public interface
  # Edit the /etc/conf.d/ucarp.pub 
  my $ucarp_pub_conf = $cfg->val("General","ucarp_pub_config");
  my $ucarp_pub_interface = $cfg->val("General","ucarp_pub_interface");
  my $ucarp_pub_opts = $cfg->val($modus,"ucarp_opts");
  my $ucarp_pub_rip = $localNetworkHash->{'pub'}->{'ip'};
  my $ucarp_pub_vip = $localNetworkHash->{'pub'}->{'vip'};
  my $ucarp_pub_netmask = $localNetworkHash->{'pub'}->{'netmask'};

  # Read the configuration file
  open(FILE,$ucarp_pub_conf) || die("Could not open $ucarp_pub_conf for reading.");
  @output = <FILE>;
  close FILE;

  # Write the file and directly change what needs to be changed
  open(FILE,">$ucarp_pub_conf") || die("Could not open $ucarp_pub_conf for writting.");
  foreach my $line ( @output )
  {
    # Check it the line matches
    $line = "UCARP_INTERFACE=".$ucarp_pub_interface."\n" if ( $line =~ m/<FOSS-CLOUD-PUB-INTERFACE>/ );
    $line = "UCARP_SOURCEADDRESS=$ucarp_pub_rip\n" if ( $line =~ m/<FOSS-CLOUD-PUB-RIP-ADDRESS>/); 
    $line = "UCARP_VIRTUALADDRESS=$ucarp_pub_vip\n" if ( $line =~ m/<FOSS-CLOUD-PUB-VIP-ADDRESS>/); 
    $line = "UCARP_VIRTUALPREFIX=$ucarp_pub_netmask\n" if ( $line =~ m/<FOSS-CLOUD-PUB-NETMASK>/); 
    $line = "UCARP_OPTS=\"--shutdown $ucarp_pub_opts\"\n" if ( $line =~ m/<FOSS-CLOUD-UCARP-OPTS>/); 

    # Write the line to the file
    print FILE $line;

  }
  close FILE;

  # Write the password to the password file
  my $ucarp_password_file = $cfg->val("General","ucarp_pub_password_file");
  open(FILE,">$ucarp_password_file") || die("Could not open $ucarp_password_file for writting.");
  print FILE $ucarp_password;
  close FILE;

  # Do the same thing for the internal interface
  # Public interface
  # Edit the /etc/conf.d/ucarp.int
  my $ucarp_int_conf = $cfg->val("General","ucarp_int_config");
  my $ucarp_int_opts = $cfg->val($modus,"ucarp_opts");
  my $ucarp_int_interface = "vlan".$localNetworkHash->{'int'}->{'id'};
  my $ucarp_int_rip = $localNetworkHash->{'int'}->{'ip'};
  my $ucarp_int_vip = $localNetworkHash->{'int'}->{'vip'};
  my $ucarp_int_netmask = $localNetworkHash->{'int'}->{'netmask'};

  # Read the configuration file
  open(FILE,$ucarp_int_conf) || die("Could not open $ucarp_int_conf for reading.");
  @output = <FILE>;
  close FILE;

  # Write the file and directly change what needs to be changed
  open(FILE,">$ucarp_int_conf") || die("Could not open $ucarp_int_conf for writting.");
  foreach my $line ( @output )
  {
    # Check it the line matches
    $line = "UCARP_INTERFACE=$ucarp_int_interface\n" if ( $line =~ m/<FOSS-CLOUD-INT-INTERFACE>/ );
    $line = "UCARP_SOURCEADDRESS=$ucarp_int_rip\n" if ( $line =~ m/<FOSS-CLOUD-INT-RIP-ADDRESS>/); 
    $line = "UCARP_VIRTUALADDRESS=$ucarp_int_vip\n" if ( $line =~ m/<FOSS-CLOUD-INT-VIP-ADDRESS>/); 
    $line = "UCARP_VIRTUALPREFIX=$ucarp_int_netmask\n" if ( $line =~ m/<FOSS-CLOUD-INT-NETMASK>/); 
    $line = "UCARP_OPTS=\"--shutdown $ucarp_int_opts\"\n" if ( $line =~ m/<FOSS-CLOUD-UCARP-OPTS>/); 

    # Write the line to the file
    print FILE $line;

  }
  close FILE;

  # Check the ucarp password for the int interface
  if ( $ucarp_int_password eq "" )
  {
    $ucarp_password = chars(8,8);
  } else
  {
    $ucarp_password = $ucarp_int_password;
  }

  # Write the password to the password file
  $ucarp_password_file = $cfg->val("General","ucarp_int_password_file");
  open(FILE,">$ucarp_password_file") || die("Could not open $ucarp_password_file for writting.");
  print FILE $ucarp_password;
  close FILE;

  # Now the configuration phase is finished, we can create the symlinks to the
  # init script
  symlink("/etc/init.d/ucarp","/etc/init.d/ucarp.pub");
  symlink("/etc/init.d/ucarp","/etc/init.d/ucarp.int");

}

################################################################################
# configureFc-brockerd
################################################################################
# Description:
#   Configures and starts the fc-brockerd.
# Usage:
#   configureFc-brockerd($configuration);
################################################################################
# Return Values:
#   none
################################################################################

sub configureFcBrokerd {

  my ($localNetworkHash, $openldap_bind_password)=@_;

  # Configuring the fc-brokerd daemon
  print "\n";
  header("Configuring the fc-brokerd daemon ...");

  # Get the necessary variables
  my $fc_brokerd_template_file = $cfg->val($modus,"file_fc_brokerd_conf_template");
  my $fc_brokerd_config_file = $cfg->val("General","file_fc_brokerd_conf");

  # OpenLDAP runs on the int VLAN
  my $localIntIP = $localNetworkHash->{"int"}->{"vip"};
  $localIntIP = $localNetworkHash->{"int"}->{"ip"} if ( $modus eq "demo-system" );
  my $openldap_port = $cfg->val("openLDAP","port");
  $openldap_port = "389" if ( $modus eq "demo-system" );

  # Get the bind- and basedn
  my $openldap_binddn = $cfg->val("openLDAP","binddn");
  my $openldap_basedn = $cfg->val("openLDAP","basedn");

  # Working on the file /var/www/localhost/htdocs/phpldapadmin/config/config.php
  print "\n";
  print "Working on $fc_brokerd_template_file ...\n";

  my $ldap_uri;
  if ( $modus eq "demo-system" )
  {
    $ldap_uri = "ldap://".$localIntIP;
  } else
  {
    $ldap_uri = "ldaps://ldapm.".$localNetworkHash->{"pub"}->{"domain"};
  }

  # Generate the search and replace commands
  my @sar_commands = (
                      {search => "<FOSS-CLOUD-LDAP-VIP-URI>", replace => $ldap_uri.":".$openldap_port},
                      {search => "<FOSS-CLOUD-BINDDN>", replace => $openldap_binddn},
                      {search => "<FOSS-CLOUD-BINDPW>", replace => $openldap_bind_password},
                      {search => "<FOSS-CLOUD-BASEDN>", replace => $openldap_basedn}
                     );

  # Execute the command
  searchAndReplace ( $fc_brokerd_template_file,
                     $fc_brokerd_config_file,
                     @sar_commands
                   );

  # Get the roots group and user id
  my $uid_root = $cfg->val("General","uid_root"); 
  my $gid_root = $cfg->val("General","gid_fc-broker"); 

  # Change the permission for the config file
  setSingleFilePermissions("file",$uid_root,$gid_root,0640,$fc_brokerd_config_file);

#  # Start the daemon and add it to de default runlevel
#  startDaemon("fc-brokerd");
#  rcUpdate("fc-brokerd","default");
}

################################################################################
# configureProvBackupKVM
################################################################################
# Description:
#   Configures and starts the prov-backup-kvm daemon
# Usage:
#   configureProvBackupKVM($configuration);
################################################################################
# Return Values:
#   none
################################################################################

sub configureProvBackupKVM {

  my ($localNetworkHash, $ldap_server, $ldap_bind_password) = @_;

  print "\n";
  header("Configuring the prov-backup-kvm daemon ...");

  # Get the necessary variables
  my $prov_backup_kvm_template_file = $cfg->val("General","file_prov_backup_kvm_conf_template");
  my $prov_backup_kvm_config_file = $cfg->val("General","file_prov_backup_kvm_conf");

  my $node_name = $localNetworkHash->{"Node Name"}.".".$localNetworkHash->{"pub"}->{"domain"};

  my $ldap_port = $cfg->val("openLDAP","port");
  $ldap_port = "389" if ( $modus eq "demo-system" );
  my $ldap_binddn = $cfg->val("prov-backup-kvm","ldap_binddn");
  my $ldap_service_subtree = $cfg->val("prov-backup-kvm","ldap_service_subtree");
  my $ldap_cookie_file = $cfg->val("prov-backup-kvm","ldap_cookie_file");
  my $ldap_default_config = $cfg->val("prov-backup-kvm","ldap_default_config");

  print "\n";
  print "Working on $prov_backup_kvm_config_file ...\n";

  my $ldap_uri;
  if ( $modus eq "demo-system" )
  {
    $ldap_uri = "ldap://".$ldap_server;
  } else
  {
    $ldap_uri = "ldaps://ldapm.".$localNetworkHash->{"pub"}->{"domain"};
  }

  # Generate the search and replace commands
  my @sar_commands = (
                      {search => "<FOSS-CLOUD-NODE-NAME>", replace => $node_name},
                      {search => "<FOSS-CLOUD-LDAP-SERVER>", replace => $ldap_uri},
                      {search => "<FOSS-CLOUD-LDAP-PORT>", replace => $ldap_port},
                      {search => "<FOSS-CLOUD-LDAP-BINDDN>", replace => $ldap_binddn},
                      {search => "<FOSS-CLOUD-LDAP-BIND-PASSWORD>", replace => $ldap_bind_password},
                      {search => "<FOSS-CLOUD-LDAP-SERVICE-SUBTREE>", replace => $ldap_service_subtree},
                      {search => "<FOSS-CLOUD-LDAP-COOKIE-FILE>", replace => $ldap_cookie_file},
                      {search => "<FOSS-CLOUD-LDAP-PROV-BACKUP-KVM-DEFAULT-CONFIGURATION>", replace => $ldap_default_config},
                     );

  # Execute the command
  searchAndReplace ( $prov_backup_kvm_template_file,
                     $prov_backup_kvm_config_file,
                     @sar_commands
                   );

  # Get the roots group and user id
  my $uid_root = $cfg->val("General","uid_root"); 
  my $gid_root = $cfg->val("General","gid_root"); 

  # Change the permission for the config file
  setSingleFilePermissions("file",$uid_root,$gid_root,0640,$prov_backup_kvm_config_file);

  # Start the daemon and add it to de default runlevel
  startDaemon("prov-backup-kvm");
  rcUpdate("prov-backup-kvm","default");
}

################################################################################
# configureIPtables
################################################################################
# Description:
#   Configures and starts the iptables.
# Usage:
#   configureIPtables($configuration);
################################################################################
# Return Values:
#   none
################################################################################

sub configureIPtables {

    my $configuration = shift;

    my @args;

    # Get the iptables command from the command line:
    my $iptables_command = $configuration->val($modus,"iptables_command");

    # Get all necessary parameters (can be more than one)
    my @iptables_parameter = $configuration->val($modus,"iptables_parameter");

    # Get the command for the rc-update
    my $rc_update_command = $configuration->val($modus,"iptables_rc-update_command");

    # Get the iptables save command
    my $iptables_save_command = $configuration->val($modus,"iptables_save_command");


    # Execute for each of the parameter the iptables command
    foreach my $parameter (@iptables_parameter)
    {

        # Generate the command array
        @args = ( $iptables_command, $parameter );

        # Execute the command with the given parameter on the command line
        if ( system( join(' ' , @args) ) )
        {
            returnError(ERROR_EXECUTE_COMMAND_CODE,ERROR_EXECUTE_COMMAND_STRING,
                        "Could not execute @args");
        }
    } # End of foreach my $parameter (@iptables_parameter)

    # Now save the iptables
    if ( system( $iptables_save_command ) )
    {
       returnError(ERROR_EXECUTE_COMMAND_CODE,ERROR_EXECUTE_COMMAND_STRING,
                        "Could not execute $iptables_save_command");
    }

    # Add the iptables to de default run-level
    rcUpdate("iptables","default");

    # And finally start the iptables daemon
    startDaemon("iptables");

} # End of configureIPtables

######################################################################################################
# createRootCA
######################################################################################################
# Description: 
#   
######################################################################################################
# Usage:
#   createRootCA();
######################################################################################################
# Return Values:
#   none
######################################################################################################

sub createRootCA
{

    # First of all set up the configuration for the CA generation: 
    # chown -R root:root /etc/ssl/FOSS-Cloud_CA
    # find /etc/ssl/FOSS-Cloud_CA -type d -exec chmod 755 {} \;
    # chmod 700 /etc/ssl/FOSS-Cloud_CA/private
    # chmod 644 /etc/ssl/FOSS-Cloud_CA/openssl.cnf
    # chmod 600 /etc/ssl/FOSS-Cloud_CA/index.txt

    # Set correct file ownership
    my @args = ( "chown",
              "-R",
              "root:root",
              "/etc/ssl/FOSS-Cloud_CA"
            );
    system( join( " ", @args ) );

    # Set directory file permission: 
    @args = ( "find",
              "/etc/ssl/FOSS-Cloud_CA",
              "-type",
              "d",
              "-exec",
              "chmod",
              "755",
              "{}",
              '\;'
            );
    system( join( " ", @args ) );

    # Set proper permission for given files:
    my $uid_root = $cfg->val("General","uid_root"); # root
    my $gid_root = $cfg->val("General","gid_root"); # root

    setSingleFilePermissions("directory",$uid_root,$gid_root,0700,"/etc/ssl/FOSS-Cloud_CA/private");
    setSingleFilePermissions("file",$uid_root,$gid_root,0644,"/etc/ssl/FOSS-Cloud_CA/openssl.cnf");
    setSingleFilePermissions("file",$uid_root,$gid_root,0600,"/etc/ssl/FOSS-Cloud_CA/index.txt");

    # If it is the secondary master, just copy the root certificate from the 
    # primary master
    if ( $modus eq "secondary-master" )
    {
        # Create ssh connection and copy the root certificate
        my $ssh = Net::OpenSSH->new($primary_master_host,
                              user => $primary_master_user,
			      password => $primary_master_password,
			      master_stderr_discard => 1 # quiet
                             );

        # Copy the request to the primary master to be able to sign it
        my $rv = $ssh->scp_get("/etc/ssl/certs/FOSS-Cloud_CA.cert.pem",
                               "/etc/ssl/certs/FOSS-Cloud_CA.cert.pem");
        unless ( $rv )
        {
            print "Copy from primary master node failed: ".$ssh->error."\n";
            exit 1;
        }

        setSingleFilePermissions("file",$uid_root,$gid_root,0444,"/etc/ssl/certs/FOSS-Cloud_CA.cert.pem");
        
        # Rehash1
        @args = ("c_rehash","/etc/ssl/certs/");
        system( join( " ", @args ) );

        return;
    }


    # Now create the password file
    my $password_file = "/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt";
    open(PASSWDFILE,">$password_file") or die "Cannot open $password_file for writting";
    
    # Set propper permission
    setSingleFilePermissions("file",$uid_root,$gid_root,0400,$password_file);
    
    # Generate the password and write it to the file
    my $ca_passwd = chars(16,16);
    print PASSWDFILE $ca_passwd;
    close PASSWDFILE;

#    openssl req -new \
#            -keyout /etc/ssl/FOSS-Cloud_CA/private/FOSS-Cloud_CA.key.pem \
#            -out /etc/ssl/FOSS-Cloud_CA/requests/FOSS-Cloud_CA.req.pem \
#            -subj "/DC=org/DC=foss-cloud/OU=Certificate Authority/OU=Local FOSS-Cloud Certificate Authority/OU=<UUID>/CN=Local FOSS-Cloud Certificate Authority <UUID>" \
#            -passout file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt

    # Create the openssl request
    @args = ("openssl","req","-new",
             "-keyout","/etc/ssl/FOSS-Cloud_CA/private/FOSS-Cloud_CA.key.pem",
             "-out","/etc/ssl/FOSS-Cloud_CA/requests/FOSS-Cloud_CA.req.pem",
             "-subj",'"/DC=org/DC=foss-cloud/OU=Certificate Authority/OU=Local FOSS-Cloud Certificate Authority/OU='.$foss_cloud_uuid.'/CN=Local FOSS-Cloud CA '.$foss_cloud_uuid.'"',
             "-passout","file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt",
            );
    system( join( " ", @args ) );

#    openssl ca -config /etc/ssl/FOSS-Cloud_CA/openssl.cnf \
#           -create_serial \
#           -out /etc/ssl/FOSS-Cloud_CA/FOSS-Cloud_CA.cert.pem \
#           -days 18250 \
#           -batch \
#           -keyfile /etc/ssl/FOSS-Cloud_CA/private/FOSS-Cloud_CA.key.pem \
#           -selfsign \
#           -extensions v3_ca \
#           -infiles /etc/ssl/FOSS-Cloud_CA/requests/FOSS-Cloud_CA.req.pem \
#           -passin file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt

    # Now the request must be signed
    @args = ("openssl","ca","-config","/etc/ssl/FOSS-Cloud_CA/openssl.cnf",
             "-create_serial",
             "-out","/etc/ssl/FOSS-Cloud_CA/FOSS-Cloud_CA.cert.pem",
             "-days","18250",
             "-batch",
             "-keyfile","/etc/ssl/FOSS-Cloud_CA/private/FOSS-Cloud_CA.key.pem",
             "-selfsign",
             "-extensions","v3_ca",
             "-passin","file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt",
             "-infiles","/etc/ssl/FOSS-Cloud_CA/requests/FOSS-Cloud_CA.req.pem",
            );
    system( join( " ", @args ) );

#    cp /etc/ssl/FOSS-Cloud_CA/FOSS-Cloud_CA.cert.pem /etc/ssl/certs/.
#    chown root:root /etc/ssl/certs/FOSS-Cloud_CA.cert.pem
#    chmod 444 /etc/ssl/certs/FOSS-Cloud_CA.cert.pem
#
#    cd /etc/ssl/certs/
#    c_rehash

    # And finally install the certificate
    copy("/etc/ssl/FOSS-Cloud_CA/FOSS-Cloud_CA.cert.pem","/etc/ssl/certs/.") 
        or die "Copy failed: $!";
    setSingleFilePermissions("file",$uid_root,$gid_root,0444,"/etc/ssl/certs/FOSS-Cloud_CA.cert.pem");
    
    # Rehash1
    @args = ("c_rehash","/etc/ssl/certs/");
    system( join( " ", @args ) );

    # And finally create a symlink the the htdocs/ca directory to be able to 
    # download this certificate
    @args = ("ln","-s","/etc/ssl/certs/FOSS-Cloud_CA.cert.pem","/var/www/localhost/htdocs/ca/FOSS-Cloud_CA.cert.pem");

    # Execute the commands
    system( join(' ', @args) );

}

######################################################################################################
# createApacheCertificate
######################################################################################################
# Description: 
#   
######################################################################################################
# Usage:
#   createApacheCertificate();
######################################################################################################
# Return Values:
#   none
######################################################################################################

sub createApacheCertificate
{

    # If it is the secondary master node we just need to get the certificate 
    # from the primary master
    if ( $modus eq "secondary-master" )
    {
        # Establish the ssh connection to the remote host $host
        my $ssh = Net::OpenSSH->new($primary_master_host,
                              user => $primary_master_user,
			      password => $primary_master_password,
			      master_stderr_discard => 1 # quiet
                             );

        # Copy the request to the primary master to be able to sign it
        my $rv = $ssh->scp_get("/etc/ssl/apache2/".$apache_vip_name.".cert.pem",
                "/etc/ssl/apache2/".$apache_vip_name.".cert.pem" );
        unless ( $rv )
        {
            print "Copy from primary master node failed: ".$ssh->error."\n";
            exit 1;
        }

        # Copy the request to the primary master to be able to sign it
        $rv = $ssh->scp_get("/etc/ssl/apache2/".$apache_vip_name.".key.pem",
                "/etc/ssl/apache2/".$apache_vip_name.".key.pem" );
        unless ( $rv )
        {
            print "Copy from primary master node failed: ".$ssh->error."\n";
            exit 1;
        }

        # And finally set the correct permissions
        my $uid_root = $cfg->val("General","uid_root"); # root
        my $gid_root = $cfg->val("General","gid_root"); # root
        setSingleFilePermissions("file",$uid_root,$gid_root,0400,"/etc/ssl/apache2/".$apache_vip_name.".cert.pem");
        setSingleFilePermissions("file",$uid_root,$gid_root,0400,"/etc/ssl/apache2/".$apache_vip_name.".key.pem");

        return;
    }

    # Create and sign the certificate
#    openssl req \
#        -out /etc/ssl/apache2/foss-cloud.example.com.req.pem \
#        -nodes \
#        -keyout /etc/ssl/apache2/foss-cloud.example.com.key.pem \
#        -newkey rsa:2048 \
#        -sha1 \
#        -subj "/DC=org/DC=foss-cloud/OU=Certificate Authority/OU=<UUID>/OU=domains/CN=foss-cloud.example.com" \
#        -new \
#        -passout pass:""

    if ( $apache_vip_name eq "" )
    {
        # TODO return error
        print "Apache VIP name not set, cannot create certificate request";
        exit 1;
    }


    my $request = "/etc/ssl/apache2/".$apache_vip_name.".req.pem";
    my $key = "/etc/ssl/apache2/".$apache_vip_name.".key.pem";
    my $subject = "/DC=org/DC=foss-cloud/OU=Certificate Authority/OU="
                  .$foss_cloud_uuid."/OU=domains/CN=".$apache_vip_name;

    # Generate and execute the reqest command
    my @args = ( 'openssl','req',
                 '-out',$request,
                 '-nodes',
                 '-keyout',$key,
                 '-newkey',"rsa:2048",
                 '-sha1',
                 '-subj',"'".$subject."'",
                 '-new',
                 '-passout','pass:""'
               );
     system ( join( " ", @args ) );

     # Copy the files to the FOSS-Cloud CA directory
     copy($request,"/etc/ssl/FOSS-Cloud_CA/requests/".$apache_vip_name.".req.pem")
        or die "Copy failed: $!";
     copy($key,"/etc/ssl/FOSS-Cloud_CA/requests/".$apache_vip_name.".key.pem")
        or die "Copy failed: $!";

     # Sign the request
#     openssl ca -config /etc/ssl/FOSS-Cloud_CA/openssl.cnf \
#           -in /etc/ssl/FOSS-Cloud_CA/requests/foss-cloud.example.com.req.pem \
#           -out /etc/ssl/FOSS-Cloud_CA/certs/foss-cloud.example.com.cert.pem \
#           -passin file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt
    @args = ( "openssl","ca","-config","/etc/ssl/FOSS-Cloud_CA/openssl.cnf",
              "-in","/etc/ssl/FOSS-Cloud_CA/requests/".$apache_vip_name.".req.pem",
              "-out","/etc/ssl/FOSS-Cloud_CA/certs/".$apache_vip_name.".cert.pem",
              "-passin","file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt",
              "-batch"
            );
    system( join( " ", @args ) );

    # Copy the signed cert back to the apache directory
    copy("/etc/ssl/FOSS-Cloud_CA/certs/".$apache_vip_name.".cert.pem",
         "/etc/ssl/apache2/".$apache_vip_name.".cert.pem") 
         or die "Copy failed: $!";

    # And finally set the correct permissions
    my $uid_root = $cfg->val("General","uid_root"); # root
    my $gid_root = $cfg->val("General","gid_root"); # root
    setSingleFilePermissions("file",$uid_root,$gid_root,0400,"/etc/ssl/apache2/".$apache_vip_name.".cert.pem");
    setSingleFilePermissions("file",$uid_root,$gid_root,0400,"/etc/ssl/apache2/".$apache_vip_name.".key.pem");

}

######################################################################################################
# createLDAPCertificate
######################################################################################################
# Description: 
#   
######################################################################################################
# Usage:
#   createLDAPCertificate($loacl_network_hash);
######################################################################################################
# Return Values:
#   none
######################################################################################################

sub createLDAPCertificate
{
    my $local_network_hash = shift;

    my $domain_name = $local_network_hash->{'pub'}->{'domain'};
    my $ldap_vip_name = $cfg->val("General","ldap_vip_name").".".$domain_name;

    # Copy the ca config to create a temporary configuration with and alternativ
    # subject name
    copy("/etc/ssl/FOSS-Cloud_CA/openssl.cnf","/etc/ssl/FOSS-Cloud_CA/openssl-subjectAltName.cnf");

    # Create a config ini file object to be able to edit the file properly
    my $tmp_config = Config::IniFiles->new( -file => "/etc/ssl/FOSS-Cloud_CA/openssl-subjectAltName.cnf", -fallback => "General",  -nomultiline => 1 );

    # Check if "req_extensions" is already defined
    if ( $tmp_config->exists("req","req_extensions") )
    {
        # Overwrite the current value
        $tmp_config->setval("req","req_extensions","v3_req");
    } else
    {
        # Create the attribute req_extension with appropriate value
        $tmp_config->newval("req","req_extensions","v3_req");
    }

    # Create the section v3_req if it does not already exists
    unless( $tmp_config->SectionExists("v3_req") )
    {
        $tmp_config->AddSection("v3_req");
    }

    # Check if the given attributes exist and set proper values
    if ( $tmp_config->exists("v3_req","basicConstraints") )
    {
        # Overwrite the current value
        $tmp_config->setval("v3_req","basicConstraints","CA:FALSE");
    } else
    {
        # Create the attribute req_extension with appropriate value
        $tmp_config->newval("v3_req","basicConstraints","CA:FALSE");
    }

    # Check if the given attributes exist and set proper values
    if ( $tmp_config->exists("v3_req","keyUsage") )
    {
        # Overwrite the current value
        $tmp_config->setval("v3_req","keyUsage","nonRepudiation, digitalSignature, keyEncipherment");
    } else
    {
        # Create the attribute req_extension with appropriate value
        $tmp_config->newval("v3_req","keyUsage","nonRepudiation, digitalSignature, keyEncipherment");
    }

    # Check if the given attributes exist and set proper values
    if ( $tmp_config->exists("v3_req","subjectAltName") )
    {
        # Overwrite the current value
        $tmp_config->setval("v3_req","subjectAltName","DNS:".$ldap_vip_name);
    } else
    {
        # Create the attribute req_extension with appropriate value
        $tmp_config->newval("v3_req","subjectAltName","DNS:".$ldap_vip_name);
    }

    # Finally write the changes to the file:
    $tmp_config->RewriteConfig();

    # Get the correct cert name 
    my $ldap_host_name = "";
    if ( $modus eq "primary-master" || $modus eq "single-server" )
    {
        $ldap_host_name = "ldapm-01.".$domain_name;
    } else
    {
        $ldap_host_name = "ldapm-02.".$domain_name;
    }

    # Now we can finally create the certificate
#    openssl req \
#    -config /etc/ssl/openssl-subjectAltName.cnf \
#    -out ldapm-01.example.com.req.pem \
#    -nodes \
#    -keyout keys/ldapm-01.example.com.key.pem \
#    -newkey rsa:2048 \
#    -sha1 \
#    -subj "/DC=org/DC=foss-cloud/OU=Certificate Authority/OU=Local FOSS-Cloud Certificate Authority/OU=<UUID>/OU=domains/CN=ldapm-01.example.com" \
#    -new
#    -passout pass:""
    my $subject = "/DC=org/DC=foss-cloud/OU=Certificate Authority/OU=Local "
                 ."FOSS-Cloud Certificate Authority/OU=".$foss_cloud_uuid
                 ."/OU=domains/CN=".$ldap_host_name;

    my @args = ( "openssl","req",
                 "-config","/etc/ssl/FOSS-Cloud_CA/openssl-subjectAltName.cnf",
                 "-out","/etc/openldap/ssl/".$ldap_host_name.".req.pem",
                 "-nodes",
                 "-keyout","/etc/openldap/ssl/keys/".$ldap_host_name.".key.pem",
                 "-newkey","rsa:2048",
                 "-sha1",
                 "-subj","'".$subject."'",
                 "-new",
                 "-passout",'pass:""',
               );
    system( join( " ", @args ) );

    # Remove the temporary config file
    unlink("/etc/ssl/FOSS-Cloud_CA/openssl-subjectAltName.cnf");

    # Copy the request to the FOSS-Cloud CA directory to sign it
    my $ssh;
    if ( $modus eq "primary-master" || $modus eq "single-server" )
    {
        copy("/etc/openldap/ssl/".$ldap_host_name.".req.pem",
             "/etc/ssl/FOSS-Cloud_CA/requests/".$ldap_host_name.".req.pem");
    } else
    {
        
        # Establish the ssh connection to the remote host $host
        $ssh = Net::OpenSSH->new($primary_master_host,
                              user => $primary_master_user,
			      password => $primary_master_password,
			      master_stderr_discard => 1 # quiet
                             );

        # Copy the request to the primary master to be able to sign it
        my $rv = $ssh->scp_put("/etc/openldap/ssl/".$ldap_host_name.".req.pem",
                "/etc/ssl/FOSS-Cloud_CA/requests/".$ldap_host_name.".req.pem" );
        unless ( $rv )
        {
            print "Copy to primary master node failed: ".$ssh->error."\n";
            exit 1;
        }
    }

    # Sign the request
#    openssl ca -config /etc/ssl/FOSS-Cloud_CA/openssl.cnf \
#           -in /etc/ssl/FOSS-Cloud_CA/requests/ldapm-01.example.com.req.pem \
#           -out /etc/ssl/FOSS-Cloud_CA/certs/ldapm-01.example.com.cert.pem
#           -passin file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt
    
    @args = ( "openssl","ca",
              "-config","/etc/ssl/FOSS-Cloud_CA/openssl.cnf",
              "-in","/etc/ssl/FOSS-Cloud_CA/requests/".$ldap_host_name.".req.pem",
              "-out","/etc/ssl/FOSS-Cloud_CA/certs/".$ldap_host_name.".cert.pem",
              "-passin","file:/etc/ssl/FOSS-Cloud_CA/private/passphrase.txt",
              "-batch"
            );
    if ( $modus eq "primary-master" || $modus eq "single-server" )
    {
        # Execute the commands locally
        system( join( " ", @args ) );
    } else
    {
        # Execute the command on the primary master node
        unless ( $ssh->system(join( " ", @args ) ) )
        {
            print "Could not execute sign command on remote host: ";
            print $ssh->error."\n";
            exit 1;
        }
    }

    # And copy the cert back the the openldap directory
    if ( $modus eq "primary-master" || $modus eq "single-server" )
    {
        copy( "/etc/ssl/FOSS-Cloud_CA/certs/".$ldap_host_name.".cert.pem",
              "/etc/openldap/ssl/".$ldap_host_name.".cert.pem");
    } else
    {
        # Get the signed cert from the primary master
        my $rv = $ssh->scp_get("/etc/ssl/FOSS-Cloud_CA/certs/".$ldap_host_name.".cert.pem",
                             "/etc/openldap/ssl/".$ldap_host_name.".cert.pem");
        unless ( $rv )
        {
            print "Copy from primary master node failed: ".$ssh->error."\n";
            exit 1;
        }
    }

    # And finally set correct file permission
    my $uid_root = $cfg->val("General","uid_root"); # root
    my $gid_root = $cfg->val("General","gid_root"); # root
    my $uid_ldap = $cfg->val("General","uid_ldap"); # ldap
    my $gid_ldap = $cfg->val("General","gid_ldap"); # ldap

    @args = ("chown","-R","root:ldap","/etc/openldap/ssl");
    system( join( " ", @args ) );

    setSingleFilePermissions("directory",$uid_root,$gid_ldap,0750,"/etc/openldap/ssl");
    setSingleFilePermissions("directory",$uid_root,$gid_ldap,0750,"/etc/openldap/ssl/keys");
    setSingleFilePermissions("file",$uid_root,$gid_ldap,0440, "/etc/openldap/ssl/".$ldap_host_name.".cert.pem");
    setSingleFilePermissions("file",$uid_ldap,$gid_ldap,0400, "/etc/openldap/ssl/keys/".$ldap_host_name.".key.pem");

}

######################################################################################################
# header
######################################################################################################
# Description: 
#   Prints nice header boxes, dependent on the console width:
#   +-----------------------+
#   |    title              |
#   +-----------------------+
######################################################################################################
# Usage:
#   header("My very first title");
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub header {
  my ($title) = @_;
  my ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

  print "+" . ( "-" x ($wchar - 2) ) . "+\n";
  print "|   $title" . ( " " x ($wchar - (length($title) + 5) ) ) . "|\n";
  print "+" . ( "-" x ($wchar - 2) ) . "+\n";

} # End of sub header


######################################################################################################
# proceed
######################################################################################################
# Description: 
#   Asks the user, if the installation should really proceed
######################################################################################################
# Usage:
#   proceed();
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub proceed {
  my ($type) = @_;
  my $answer;

  # Asks the user, if the installation should really proceed
  print "Do you really want to proceed with configuration of the $type?\n";
  print "yes or no (default: no): ";
  chomp($answer = <STDIN>);
  print "\n";

  # If no answer was given, take default one (no)
  unless($answer){
    $answer = "no";
  }

  # Only proceed, if anwer is yes, otherwise abort
  if ($answer ne "yes") {
    exit 0;
  }   

} # End of sub proceed

######################################################################################################
# enableIPv4Forwarding
######################################################################################################
# Description: 
#   Enables IPv4 forwarding by creating the file /etc/sysctl/routing.conf and 
#   executing the corresponding sysctl command
######################################################################################################
# Usage:
#   enableIPv4Forwarding();
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub enableIPv4Forwarding 
{

    # Create the file /etc/sysctl.d/routing.conf and add net.ipv4.ip_forward = 1
    # to it
    if ( ! open( FILE, ">/etc/sysctl.d/routing.conf" ) )
    {
        #TODO
#        returnError();
    } else
    {
        # Write the content to the file
        print FILE "# enable routing for NAT\n";
        print FILE "net.ipv4.ip_forward = 1\n";
        close FILE;
    }

    # And finally execute the sysctl command that the changes take place 
    # immediatly
    if ( system ("sysctl net.ipv4.ip_forward=1") )
    {
        print "Cloud not execute command: \n\nsysctl net.ipv4.ip_forward=1\n\n";
        print "Execute it after the installation manually to enable IPv4";
        print "forwarding\n";
        sleep 10;
    }

}

######################################################################################################
# setSingleFilePermissions
######################################################################################################
# Description: 
#   Set the permissions according to the parameters passed.
######################################################################################################
# Usage:
#   setSingleFilePermissions($type,$uid,$gid,$permissions,$file);
#   $type        : file or directory
#   $uid         : numeric user id (0 for root, 439 for ldap, ...)
#   $gid         : numeric group id (0 for root, 439 for ldap, ...)
#   $permissions : permission arguments (for example 0640 or 0755)
#   $file        : file name with the full path (for example /etc/openldap/slapd.conf)
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub setSingleFilePermissions {
  my ($type,$uid,$gid,$permissions,$file) = @_;

  # Setting the proper permisions on the file /etc/openldap/slapd.conf ...
  print "Setting the proper permissions on the $type $file ...\n";
  if (!$dryrun) {
    if ($debug) {
      print "Executing: chmod $permissions, $file\n";
    } # End of if ($debug)
    unless (chmod $permissions, $file) {
      print "Could not chmod the the $type $file to $permissions, still proceeding ...\n";
    }
    if ($debug) {
      print "Executing: chown $uid, $gid, $file\n";
    } # End of if ($debug)
    unless (chown $uid, $gid, $file) {
      print "Could not chown the $type $file to uid $uid and gid $gid, still proceeding ...\n";
    }
  } else {
    if ($debug) {
      print "--dry-run: chmod $permissions, $file\n";
      print "--dry-run: chown $uid, $gid, $file\n"
    } # End of if ($debug)
  } # End of if (!$dryrun)

} # End of setSingleFilePermissions


######################################################################################################
# setMultipleFilePermissions
######################################################################################################
# Description: 
#   Set the permissions according to the parameters passed.
######################################################################################################
# Usage:
#   setMultipleFilePermissions($uid,$gid,$permissions,$directory);
#   $uid         : numeric user id (0 for root, 439 for ldap, ...)
#   $gid         : numeric group id (0 for root, 439 for ldap, ...)
#   $permissions : permission arguments (for example 0640 or 0755)
#   $directory   : the directory, which holds the files to be changed (for example /etc/openldap/acl)
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub setMultipleFilePermissions {
  my ($uid,$gid,$permissions,$directory) = @_;
  my $file;

  opendir(DIR, $directory);
  while ($file = readdir(DIR)) {
    # Use a regular expression to ignore files beginning with a period
    next if ($file =~ m/^\./);
    setSingleFilePermissions("file",$uid,$gid,$permissions,$directory."/".$file);
  } # End of while ($file = readdir(DIR))
  closedir(DIR);

} # End of sub setMultipleFilePermissions


######################################################################################################
# askForOpenLDAPPassword
######################################################################################################
# Description: 
#   Asks the user for the OpenLDAP Manager password
######################################################################################################
# Usage:
#   ($password,$unencrypted_password) = askForOpenLDAPPassword($openldap_binddn);
######################################################################################################
# Return Values:
#   $passwd :               The OpenLDAP Manager password as a {SSHA} encrypted string.
#                           The hash was generated using the command "slappasswd -s 'secret'".
#                           For example: {SSHA}sXhbUawnUmzfn7sWEKqj9uMh2G6qvO+P
#   $unencrypted_password : The same password, unencrypted, for example secret
######################################################################################################
sub askForOpenLDAPPassword {

  # Set the binddn
  my ($openldap_binddn, $type) = @_;

  my $password;
  my $unencrypted_password;
  my $errorCode;

  # Create two different passwords to be able to check whether the entered
  # password is equal
  my $pass1 = "a";
  my $pass2 = "b";

  while ( $pass1 ne $pass2 )
  {

      # Ask the user for the OpenLDAP Manager password
      print "Please $type the password for $openldap_binddn: ";

      # Disable the echo on the terminal, so no one can see your top secret password
      system('stty','-echo');
      chomp($pass1 = <STDIN>);
      system('stty','echo');

      if ( $type eq "enter" )
      {
        $unencrypted_password = $pass1;
        $password = `/usr/sbin/slappasswd -s '$unencrypted_password'`;
        chomp($password);
        return ($password,$unencrypted_password);
      }

      # Enable the echo on the terminal for the following output 
      print "\nPlease enter the same password again: ";

      # Disable the echo on the terminal, so no one can see your top secret password
      system('stty','-echo');
      chomp($pass2 = <STDIN>);

      # Enable the echo on the terminal for the following output 
      system('stty','echo');

      # Test if the passwords are the same, if not tell the user to try again
      if ( $pass1 ne $pass2 )
      {
          print "\nPasswords do not match, please try again.\n\n";
      }
  }

  # At this point the passwords the user entered are the same:-)
  print "\n\n";
  $unencrypted_password = $pass1;

  $password = `/usr/sbin/slappasswd -s '$unencrypted_password'`;
  $errorCode = $? >> 8;

  chomp($password);

  if($errorCode != 0) {
    returnError(ERROR_PASSWORD_NOT_CREATED_CODE,ERROR_PASSWORD_NOT_CREATED_STRING,"Could not encrypt the password with slappasswd.");
  } # End of if($errorCode != 0)

  # Return the OpenLDAP Manager password
  return ($password,$unencrypted_password);

} # End of sub askForOpenLDAPPassword


######################################################################################################
# createDirectoryStructure
######################################################################################################
# Description: 
#   Creates the neccessary directory structure. If it alreay exists, the current directory structure
#   is deleted.
######################################################################################################
# Usage:
#   createDirectoryStructure($uid,$gid,$permissions,$directory);
#   $uid         : numeric user id (0 for root, 439 for ldap, ...)
#   $gid         : numeric group id (0 for root, 439 for ldap, ...)
#   $permissions : permission arguments (for example 0640 or 0755)
#   $directory   : the directory, which holds the OpenLDAP data (for example 
#                  /var/lib/openldap-hdb/foss-cloud)
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub createDirectoryStructure {
  my ($uid,$gid,$permissions,$directory) = @_;
  my @directoryArray;

  print "Creating the directory structure: $directory\n";
  @directoryArray = split '/', $directory;

  # Check if /var/lib exists
  if (-d "/$directoryArray[1]/$directoryArray[2]") {
    print "/$directoryArray[1]/$directoryArray[2] exists, proceeding ...\n";
  } else {
    returnError(ERROR_MISSING_DIRECTORY_CODE,ERROR_MISSING_DIRECTORY_STRING,"/$directoryArray[1]/$directoryArray[2] does not exist, something is seriously wrong with you system!");
  } # End of if (-d "/$directoryArray[1]/$directoryArray[2]")

  # Check if /var/lib/openldap-hdb exists
  if (-d "/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]") {
    if (!$dryrun) {
      print "/$directoryArray[1]/$directoryArray[2]/$directoryArray[3] exists, trying to remove ...\n";
      if (rmtree("/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]", 0, 0)) {
        print "/var/lib/openldap-hdb successfully removed.\n";
      } else {
        returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
      } # End of if (rmtree("/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]", 0, 0))
    } else {
      print "--dry-run: Would delete /$directoryArray[1]/$directoryArray[2]/$directoryArray[3] with rmtree!\n";
    } # End of if (!$dryrun)
  } # End of if (-d "/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]")

  # Create the directory /var/lib/openldap-hdb/foss-cloud
  if (!$dryrun) {
    unless (defined eval {mkpath("/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]/$directoryArray[4]",1)}) {
      returnError(ERROR_UNDEFINED_CODE,ERROR_UNDEFINED_STRING);
    } # End of unless mkpath("/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]/$directoryArray[4]",1)
  } else {
    print "--dry-run: Would create /$directoryArray[1]/$directoryArray[2]/$directoryArray[3]/$directoryArray[4] with mkpath!\n";
  } # End of if (!$dryrun)
  # Set the correct permissions
  setSingleFilePermissions("directory",$uid,$gid,$permissions,"/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]");
  setSingleFilePermissions("directory",$uid,$gid,$permissions,"/$directoryArray[1]/$directoryArray[2]/$directoryArray[3]/$directoryArray[4]");

} # End of sub createDirectoryStructure


######################################################################################################
# loadOpenLDAPsingleLDIF
######################################################################################################
# Description: 
#   Loads the given file into the local OpenLDAP directory.
######################################################################################################
# Usage:
#   loadOpenLDAPsingleLDIF($server,$password,$ldif);
######################################################################################################
# Return Values:
#   none
######################################################################################################
sub loadOpenLDAPsingleLDIF {
  my ($server,$password,$ldif) = @_;
  my $output;
  my $errorCode;

  my $ldap_protocol;
  if ( $modus eq "demo-system" )
  {
    $ldap_protocol = "ldap://";
  } else
  {
    $ldap_protocol = "ldaps://";
  }

  # Load the given LDIF into the directory server with ldapadd
  if (!$dryrun) {
    print "Working on $ldif ...\n";
    $output = `/usr/bin/ldapadd -M -H "$ldap_protocol$server" -w $password -x -D "cn=Manager,dc=foss-cloud,dc=org" -f $ldif`;
    $errorCode = $? >> 8;

    if($errorCode != 0) {
      returnError(ERROR_LOADING_LDIF_CODE,ERROR_LOADING_LDIF_STRING,"Could not load $ldif into the OpenLDAP server with ldapadd.");
    } else {
      print $output;
    } # End of if($errorCode != 0)
  } else {
    print "/usr/bin/ldapadd -M -H \"ldap://$server\" -w $password -x -D \"cn=Manager,dc=foss-cloud,dc=org\" -f $ldif\n";
  } # End of if (!$dryrun)

} # End of loadOpenLDAPsingleLDIF

######################################################################################################
# unpackVirtualizationDataTarball
######################################################################################################
# Description:
#   Unpacks the given tarball to the given destination keeping the permissions
######################################################################################################
# Usage:
#   unpackVirtualizationDataTarball();
######################################################################################################
# Return Values:
#   0 on success
#   1 otherwise
######################################################################################################
sub unpackVirtualizationDataTarball {

  my $tarball = shift;
  my $destination = shift;

  print "\nUnpacking tarball $tarball, depending on it's size this action can "
       ."take some minutes ...\n";

  # Generate the system commands
  my @args= ("tar",
             "xjpf",
             $tarball,
             "-C",
             $destination);

  # Execute the command if not in dry-run
  unless ( $dryrun )
  {

      # Execute the commands and test if this was successful
      if ( system ( join(" " , @args ) ) )
      {
          # If the command failed, retrun 1
          return ERROR_UNDEFINED_CODE;
      }

  } else # If in dry-run just print out the command
  {
      print join(" ",@args)."\n\n";
  }

  # Return 0 if everything is ok
  return SUCCESS_CODE;

} # end sub unpackVirtualizationDataTarball


######################################################################################################
# searchAndReplace
######################################################################################################
# Description:
#   
######################################################################################################
# Usage:
#   searchAndReplace( $template_file, $output_file, @search_replace_commands );
######################################################################################################
# Return Values:
#   none
######################################################################################################

sub searchAndReplace
{
    my $template = shift;
    my $output_file = shift;
    my @sar_commands = @_;

    my $search;
    my $replace;

    # Test if the template file exists and is readable
    unless ( -r $template )
    {
        returnError(ERROR_MISSING_FILE_CODE,
                    ERROR_MISSING_FILE_STRING,
                    "Could not open $template for reading");
    }

    # Open the template file in reading mode
    open(INPUT,$template);
    # Open the LDIF file in writing mode
    open(OUTPUT,">$output_file") || die("Could not open $output_file for writing.");

    # Go through the hole file
    while(<INPUT>)
    {

        # Check for each line if we have to replace the "search" pattern with the "replace" string
        foreach my $command (@sar_commands)
        {

            $search = $command->{"search"};
            $replace= $command->{"replace"};

            $_ =~s/$search/$replace/g;
        }

        # If not in dry-run write to the OUTPUT-file, else to STDOUT
        if(!$dryrun)
        {
            print OUTPUT $_;
        } else
        {
            print "--dryrun: $_";
        }
    }

    # Close the files
    close INPUT;
    close OUTPUT;

}

################################################################################
# createBackupDirectorySymlink
################################################################################
# Description:
#   
################################################################################
# Usage:
#   createBackupDirectorySymlink( );
################################################################################
# Return Values:
#   none
################################################################################

sub createBackupDirectorySymlink
{
    # Check if the directory already exists
    return if ( -d "/var/backup" );

    # Arguments for system calls
    my @args; 

    # Check if we need to create the backup direcory
    unless ( -d "/var/virtualization/backup" )
    {
        # If not create it
        @args = ("mkdir","/var/virtualization/backup");

        # Execute the commands
        system( join(' ', @args) );

        # Test if it was successful
        if ( $? == 0 )
        {
            print "\nDirectory /var/virtualization/backup created\n";
        } else
        {
            returnError(ERROR_CANNOT_CREATE_BACKUP_DIR_CODE,ERROR_CANNOT_CREATE_BACKUP_DIR_STRING);
        }
    }

    # Create a symlink on the /var directory with the name backup which links to
    # /var/virtualization directory which is bigger.
    # So the symlink /var/backup will point to /var/virtualization/backup
    @args = ("ln","-s","/var/virtualization/backup","/var/backup");

    # Execute the commands
    system( join(' ', @args) );

    # Test if it was successful
    if ( $? == 0 )
    {
        print "\n\nCreated backup directory symlink: /var/backup --> /var/virtuali"
             ."zation/backup, if you want to change the backup directory you "
             ."may do so by modifing this symlink.\n";
    } else
    {
        print "\n\nCould not create backup directory symlink: /var/backup --> /var/"
             ."virtualization/backup, try to create manually by executing the "
             ."following command: @args\n";
    }

}



################################################################################
# askVIP
################################################################################
# Description:
#   
################################################################################
# Usage:
#   askVIP( );
################################################################################
# Return Values:
#   Array of hashes of the VIPs
################################################################################

sub askVIP
{
    my $localPubDomain =  shift;

    # define the iterfaces and vlans
    my @interfaces = ("pub","admin","data","int");
    my @vlans = (140,110,120,130);

    # Define where we need what
    my @vip_needed = $cfg->val("primary-master","interface_has_vip");
    my @secondary_master_ip_needed = $cfg->val("primary-master","vip_needs_secondary_master_ip_for_interface");

    # the array which holds the hashes of what to ask the user
    my @vips = ();

    # Ask the user the VIP for the interfaces which have a vip
    my $i = 0;
    my $vip;
    my $secondary_ip;
    foreach my $interface ( @interfaces )
    {
        # Set the needed vars to 0
        $vip = 0;
        $secondary_ip = 0;

        # Check if this interface has a vip
        if ( grep ( $_ eq $interface, @vip_needed ) )
        {

            my $default_ip;
            if ( $vlans[$i] == 140 )
            {
                $default_ip = "192.168.140.10" ;
            } else
            {
                $default_ip = "10.1.".$vlans[$i].".10";
            }

            while ( $vip !~ m/^(\d{1,3}.){3}\d{1,3}$/ )
            {
                # Ask the user for the VIP
                print "\n\nPlease enter the VIP for the $interface-interface (V"
                      ."LAN ".$vlans[$i].")\n(default: $default_ip): ";
                chomp($vip = <STDIN>);

                # Test if the user entered something, if not take default value
                $vip = $default_ip unless ( $vip );

            }
        }

        # Check if this interface also needs the ip of the secondary sotrage
        # node
        if ( grep ( $_ eq $interface, @secondary_master_ip_needed ) )
        {
            
            my $default_ip;
            if ( $vlans[$i] == 140 )
            {
                $default_ip = "192.168.140.14" ;
            } else
            {
                $default_ip = "10.1.".$vlans[$i].".14";
            }

            while ( $secondary_ip !~ m/^(\d{1,3}.){3}\d{1,3}$/ )
            {
                # Ask the user for the VIP
                print "\n\nPlease enter the IP for the $interface-interface (VL"
                      ."AN ".$vlans[$i].") of the\nsecondary-master-node ("
                      ."default: $default_ip): ";
                chomp($secondary_ip = <STDIN>);

                # Test if the user entered something, if not take default value
                $secondary_ip = $default_ip unless ($secondary_ip);

            }
        }

        # add a hash to the ask the user array
        $vips[$i++] = ( {VIP => $vip, SECONDARY_IP => $secondary_ip } );   
    }

    # Also ask for the apache vip name
    while ( $apache_vip_name !~ m/.+\..+\..{2,3}/ )
    {
        # Ask for the apache2 VIP name
        print "\nPlease enter the apache VIP name (default: foss-cloud."
             .$localPubDomain."): ";
        chomp( $apache_vip_name = <STDIN> );

        # If no name is entered take default one
        $apache_vip_name = "foss-cloud.".$localPubDomain unless ( $apache_vip_name );

    }

    return @vips;
}

################################################################################
# addVIPsToNetworkConfig
################################################################################
# Description:
#   
################################################################################
# Usage:
#   asaddVIPsToNetworkConfigkVIP( @vips );
################################################################################
# Return Values:
#   none
################################################################################

sub addVIPsToNetworkConfig{

    # Get the array of hashes which is passed
    my @vips = @_;

    my @configuration;

    # Get the current network configuration
    my $current_network_conf = checkLocalNetwork();

    # Open the network config file: 
    my $network_conf = $cfg->val($modus,"file_network_conf");
    if ( -w $network_conf )
    {

        # Overwrite the current VIPs and secondary master IPs
        $current_network_conf->{'pub'}->{'vip'} = $vips[0]->{VIP} || "";
        $current_network_conf->{'pub'}->{'secondary_master_ip'} = $vips[0]->{SECONDARY_IP} || "";
        $current_network_conf->{'admin'}->{'vip'} = $vips[1]->{VIP} || "";
        $current_network_conf->{'admin'}->{'secondary_master_ip'} = $vips[1]->{SECONDARY_IP} || "";
        $current_network_conf->{'data'}->{'vip'} = $vips[2]->{VIP} || "";
        $current_network_conf->{'data'}->{'secondary_master_ip'} = $vips[2]->{SECONDARY_IP} || "";
        $current_network_conf->{'int'}->{'vip'} = $vips[3]->{VIP} || "";
        $current_network_conf->{'int'}->{'secondary_master_ip'} = $vips[3]->{SECONDARY_IP} || "";

        # Test if a gateway is defined, if not set it to "" to avoid warning 
        # messages on STDOUT
        $current_network_conf->{'pub'}->{'gateway'} = "" unless ($current_network_conf->{'pub'}->{'gateway'});
        $current_network_conf->{'admin'}->{'gateway'} = "" unless ($current_network_conf->{'admin'}->{'gateway'});
        $current_network_conf->{'data'}->{'gateway'} = "" unless ($current_network_conf->{'data'}->{'gateway'});
        $current_network_conf->{'int'}->{'gateway'} = "" unless ($current_network_conf->{'int'}->{'gateway'});


        # Generate the new public interface string
        my $pub_string = $current_network_conf->{'Node Name'}.","
                        ."pub,"
                        .$current_network_conf->{'pub'}->{'id'}.","
                        .$current_network_conf->{'pub'}->{'ip'}.","
                        .$current_network_conf->{'pub'}->{'domain'}.","
                        .$current_network_conf->{'pub'}->{'netmask'}.","
                        .$current_network_conf->{'pub'}->{'broadcast'}.","
                        .$current_network_conf->{'pub'}->{'gateway'}.","
                        .$current_network_conf->{'pub'}->{'vip'}.","
                        .$current_network_conf->{'pub'}->{'secondary_master_ip'};

        # Add this new string to the configuration
        push ( @configuration, $pub_string );

        # Generate the new admin interface string
        my $adm_string = $current_network_conf->{'Node Name'}.","
                        ."admin,"
                        .$current_network_conf->{'admin'}->{'id'}.","
                        .$current_network_conf->{'admin'}->{'ip'}.","
                        .$current_network_conf->{'admin'}->{'domain'}.","
                        .$current_network_conf->{'admin'}->{'netmask'}.","
                        .$current_network_conf->{'admin'}->{'broadcast'}.","
                        .$current_network_conf->{'admin'}->{'gateway'}.","
                        .$current_network_conf->{'admin'}->{'vip'}.","
                        .$current_network_conf->{'admin'}->{'secondary_master_ip'};

        # Add this new string to the configuration
        push ( @configuration, $adm_string );

        # Generate the new data interface string
        my $data_string = $current_network_conf->{'Node Name'}.","
                        ."data,"
                        .$current_network_conf->{'data'}->{'id'}.","
                        .$current_network_conf->{'data'}->{'ip'}.","
                        .$current_network_conf->{'data'}->{'domain'}.","
                        .$current_network_conf->{'data'}->{'netmask'}.","
                        .$current_network_conf->{'data'}->{'broadcast'}.","
                        .$current_network_conf->{'data'}->{'gateway'}.","
                        .$current_network_conf->{'data'}->{'vip'}.","
                        .$current_network_conf->{'data'}->{'secondary_master_ip'};

        # Add this new string to the configuration
        push ( @configuration, $data_string );

        # Generate the new internal interface string
        my $int_string = $current_network_conf->{'Node Name'}.","
                        ."int,"
                        .$current_network_conf->{'int'}->{'id'}.","
                        .$current_network_conf->{'int'}->{'ip'}.","
                        .$current_network_conf->{'int'}->{'domain'}.","
                        .$current_network_conf->{'int'}->{'netmask'}.","
                        .$current_network_conf->{'int'}->{'broadcast'}.","
                        .$current_network_conf->{'int'}->{'gateway'}.","
                        .$current_network_conf->{'int'}->{'vip'}.","
                        .$current_network_conf->{'int'}->{'secondary_master_ip'};

        # Add this new string to the configuration
        push ( @configuration, $int_string );

#        # Add the VIP information to each line of the file
#        my $i = 0;
#        foreach my $tmp ( @vips )
#        {
#            # Check if vip and/or secondary master node ip is specified and
#            # append it to the line
#            my $vip = $tmp->{VIP};
#            my $second_ip = $tmp->{SECONDARY_IP};
#
#            # remove the newline at the end of the line
#            chomp( $configuration[$i] );
#
#            # Append the comma to the line
#            $configuration[$i] .= ",";
#
#            # Append the vip to the line
#            $configuration[$i] .= $vip if ( $vip );
#
#            # Append the comma to the line
#            $configuration[$i] .= ",";
#
#            # Append the secondary ip to the line
#            $configuration[$i] .= $second_ip if ( $second_ip );
#
#            # increase the index
#            $i++;
#
#        }

        # Write the changes back to the file
        open(WRITE_FH,">$network_conf");
        foreach my $conf_line ( @configuration )
        {
            print WRITE_FH $conf_line."\n";
        }
        close WRITE_FH;


    } else
    {
        # Stop with error
        returnError(ERROR_NETWORK_CONF_MISSING_CODE,
                    ERROR_NETWORK_CONF_MISSING_STRING,
                    "The file $network_conf is not writable");
    }
    

    print "\nSuccesfully added VIP information to the network configuration ";
    print "(".$network_conf.")\n";

}

################################################################################
# getRemoteConfiguration
################################################################################
# Description:
#   
################################################################################
# Usage:
#   getRemoteConfiguration( );
################################################################################
# Return Values:
#   Differnt passwords for fc-broker, syncrepl, prov-backup-kvm and dhcp user
#   to bind to the ldap direcory as well as the apache vip name
################################################################################

sub getRemoteConfiguration
{
    # We will return these
    my $broker_password = "";
    my $syncrepl_password = "";
    my $strict_host_key_check;
    my $kvm_password = "";
    my $dhcp_password = "";
    my $apache_name = "";
    my $ucarp_pub_pwd = "";
    my $ucarp_int_pwd = "";

    # Check if the known_hosts file exists or not
    if ( -e "~/.ssh/known_hosts" ) {
      
        # If it exists, set the StrictHostKeyChecking option for SSH to yes which
        # means that we check if we connect to the correct host
        $strict_host_key_check = "StrictHostKeyChecking=yes";

    }
    else {

        # If it does not exist, set the StrictHostKeyChecking option to no, which
        # means that we add the host key to the file
        # This is actually not a very good idea, but up to now the only
        # way to ensure that the script completes its tasks
        $strict_host_key_check = "StrictHostKeyChecking=no";

    }

    # Establish the ssh connection to the remote host $host
    my $ssh = Net::OpenSSH->new($primary_master_host,
                                user => $primary_master_user,
                                password => $primary_master_password,
                                master_opts => [-o => $strict_host_key_check],
                                master_stderr_discard => 1 # quiet
                               );

    if($ssh->error){
        returnError(ERROR_NO_SSH_CONNECTION_CODE,ERROR_NO_SSH_CONNECTION_STRING,$ssh->error);
    }

    # Get the slapd config file
    my $slapd_config = $cfg->val("General","directory_openldap");
    $slapd_config .= $cfg->val("General","file_slapd_conf");

    # Create the command which is simply cat + the slapd config
    my $cmd = "cat '$slapd_config'";

    # Execute the command on the remote host
    my $output = $ssh->capture($cmd);

    # Parse the output if there was no error
    if(!$ssh->error)
    {
        # get the syncrepl password
        $syncrepl_password = $1 if ( $output =~ m/\n\s+credentials=(.+)\n/ );

        # Now cat the prov-backup-kvm config to get the uncrypted master 
        # password
        my $kvm_backup_conf = $cfg->val("General","file_prov_backup_kvm_conf");
        $cmd = "cat '$kvm_backup_conf'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $kvm_password = $1 if ($output =~ m/\nADMIN_PASSWORD\s*=\s*(.*)\n/);
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

        # Get the dhcp password
        my $dhcp_conf = $cfg->val($modus,"file_dhcp_conf");
        $cmd = "cat '$dhcp_conf'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $dhcp_password = $1 if ($output =~ m/\nldap-password\s*\"(.+)\";\n/);
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

        # Get the broker password
        my $broker_conf = $cfg->val("General","file_fc_brokerd_conf");
        $cmd = "cat '$broker_conf'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $broker_password = $1 if ($output =~ m/\nbindpwd\s*=\s*(.+)\n/ );
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

        # Get the apache vip name
        my $apache_conf = "/etc/apache2/vhosts.d/localhost.conf";
        $cmd = "cat '$apache_conf'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $apache_name = $1 if ( $output =~ m/\n\s*ServerName\s+(.+)\n/ );
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

        # Get the ucarp int password
        my $ucarp_int = $cfg->val("General","ucarp_int_password_file");
        $cmd = "cat '$ucarp_int'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $ucarp_int_pwd = $output;
            chomp( $ucarp_int_pwd );
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

        # Get the ucarp pub password
        my $ucarp_pub = $cfg->val("General","ucarp_pub_password_file");
        $cmd = "cat '$ucarp_pub'";

        # Execute the command on the remote host
        $output = $ssh->capture($cmd);

        if ( !$ssh->error )
        {
            $ucarp_pub_pwd = $output;
            chomp( $ucarp_pub_pwd );
        } else
        {
            returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
        }

    }
    else{
        # If we reach this point, it means that the ssh command could not be executed.
        returnError(ERROR_SSH_CMD_FAILED_CODE,ERROR_SSH_CMD_FAILED_STRING,$ssh->error);
    }

    # Quit the connection
    $ssh->system("exit");

    # Test if both passwords were found
    if ( $syncrepl_password eq "" or $dhcp_password eq "" or $kvm_password eq "" 
         or $broker_password eq "" or $ucarp_pub_pwd eq "" 
         or $ucarp_int_pwd eq "" )
    {
        returnError(ERROR_PASSWORD_NOT_FOUND_CODE,ERROR_PASSWORD_NOT_FOUND_STRING);
    }

    # Return the passwords
    return ( $syncrepl_password, $dhcp_password, $kvm_password, $broker_password,
             $apache_name, $ucarp_pub_pwd, $ucarp_int_pwd );
}

################################################################################
# wirteVIPToHosts
################################################################################
# Description:
#   
################################################################################
# Usage:
#   wirteVIPToHosts( $localNetworkHash );
################################################################################
# Return Values:
#   none
################################################################################

sub wirteVIPToHosts
{
    my $local_network_hash = shift;

    # What is the hosts file
    my $hosts_file = $cfg->val("General","file_hosts");
    my @hosts;

    # Line numbers to replace
    my $int_vip_line_number = 0;
    my $int_second_ip_line_number = 0;
    my $pub_vip_line_number = 0;
    my $int_current_ip_line_number = 0;

    # If the hosts file is not writable we cannot continue
    if ( ! open( HOSTS, "$hosts_file" ) )
    {
        # TODO 
#        returnError();
    } else
    {

        # Read the hosts file and close the FH
        @hosts = <HOSTS>;
        close HOSTS;

        # Go through the hosts file and check if there is already a vip added
        # for the internal and public interface
        # Initialize the counter to remember the line
        my $line_number = 0;
        foreach my $host_line ( @hosts )
        {
            # If the current line is the comment for the internal VIP then the
            # next line will be the LDAP VIP and LDAP VIP name 
            if ( $host_line eq "# Int VIP for LDAP\n" )
            {
                $int_vip_line_number = $line_number + 1;
            }

            # If the current line is the comment for the internal second IP then
            # the next line will be the LDAP IP and LDAP name for the second 
            # master node
            if ( $host_line eq "# Seconadary master IP for LDAP\n" )
            {
                $int_second_ip_line_number = $line_number + 1;
            }

            # If the current line is the comment for the public VIP then the
            # next line will be the apache VIP and apache VIP name 
            if ( $host_line eq "# Public VIP for apache\n" )
            {
                $pub_vip_line_number = $line_number + 1;
            }

            if ( $host_line eq "# This hosts int IP for LDAP\n" )
            {
                $int_current_ip_line_number = $line_number + 1;
            }

            # Increase the line number
            $line_number++;
        }
        

        # Get the ldap vip this is the int vip
        my $ldap_vip = $local_network_hash->{'int'}->{'vip'};
        my $ldap_name = $cfg->val("General","ldap_vip_name");
        $ldap_name .=  ".".$local_network_hash->{'pub'}->{'domain'};

#        # Write the ldap vip name and the ip to the hosts file
#        print HOSTS "# Int VIP for LDAP\n$ldap_vip\t$ldap_name\n";

        # Write the secondary ldap ip and name to the hosts file
        my $second_ldap_ip = $local_network_hash->{'int'}->{'secondary_master_ip'};
        my $second_ldap_name = $cfg->val($modus,"ldap_domaim_name_for_hosts_file");
        my $my_ldap_name;
        my $my_ldap_ip = $local_network_hash->{'int'}->{'ip'};

        # Write the ldap name and ip for the current host
        if ( $second_ldap_name eq $cfg->val("primary-master","ldap_domaim_name_for_hosts_file") )
        {
            # We are on the primary master node
            $my_ldap_name = $cfg->val("secondary-master","ldap_domaim_name_for_hosts_file")
        } else
        {
            # We are on the secondary master
            $my_ldap_name = $cfg->val("primary-master","ldap_domaim_name_for_hosts_file")
        }

        $second_ldap_name .= ".".$local_network_hash->{'pub'}->{'domain'};
        $my_ldap_name .= ".".$local_network_hash->{'pub'}->{'domain'};

#        # Write the secondary ldap name and the ip to the hosts file
#        print HOSTS "# Seconadary master IP for LDAP\n";
#        print HOSTS "$second_ldap_ip\t$second_ldap_name\n";        

        # Get the apache vip this is the pub vip
        my $apache_vip = $local_network_hash->{'pub'}->{'vip'};
        
#        # Write the apache vip name and ip to the hosts file
#        print HOSTS "# Public VIP for apache\n$apache_vip\t$apache_vip_name\n";
        
        # Now we need to check if the lines were found, if yes replace it, if
        # not append it to the file
        # Test the int vip
        if ( $int_vip_line_number > 0 )
        {
            $hosts[$int_vip_line_number] = "$ldap_vip\t$ldap_name\n";
        } else
        {
            push ( @hosts, "\n# Int VIP for LDAP\n" );
            push ( @hosts, "$ldap_vip\t$ldap_name\n" );
        }

        # Test the int second ip
        if ( $int_second_ip_line_number > 0 )
        {
            $hosts[$int_second_ip_line_number] = "$second_ldap_ip\t"
                                                ."$second_ldap_name\n";
        } else
        {
            push ( @hosts, "# Seconadary master IP for LDAP\n" );
            push ( @hosts, "$second_ldap_ip\t$second_ldap_name\n" );
        }

        # Test the pub vip
        if ( $pub_vip_line_number > 0 )
        {
            $hosts[$pub_vip_line_number] = "$apache_vip\t$apache_vip_name\n";
        } else
        {
            push ( @hosts, "# Public VIP for apache\n" );
            push ( @hosts, "$apache_vip\t$apache_vip_name\n" );
        }

        # Test the current int ip
        if ( $int_current_ip_line_number > 0 )
        {
            $hosts[$int_current_ip_line_number] = "$my_ldap_ip\t$my_ldap_name\n";
        } else
        {
            push ( @hosts, "# This hosts int IP for LDAP\n" );
            push ( @hosts, "$my_ldap_ip\t$my_ldap_name\n" );
        }

        # Open the hosts file again for writing
        open( HOSTS, ">$hosts_file" );

        # And now rewrite the hosts file
        foreach my $line ( @hosts )
        {
            print HOSTS $line;
        }

        # Close the fh 
        close HOSTS;
    }

}
